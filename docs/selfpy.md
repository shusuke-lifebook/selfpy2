# 📒 独習 Python 第 2 版

## 📒 第 1 章 イントロダクション

### 📒 1.1.5 Python ライブラリ

- Python は「Battery Included」(電池付きで、そのまま使える)という思想もとので設計されており、このライブラリが標準で贅沢に用意されている。
- [PyPI(Python Package Index)](https://pypi.org)
  - 拡張ライブラリの集積場ともいうべきサービス

### 📒 1.2.2 Python 開発の状況

- Python の実装には PyPy、IronPython、Jython などがあるが、中でも有名は実装が**CPython**である。
- 非営利団体である[**Python ソフトウェア財団**](https://www.python.org/psf/)が管理している。[オープンソース](https://github.com/python/cpython/)として提供される。

## 📒 第 2 章 Python の基礎

### 📒 2.1 変数

**変数**とは一言で表すと「データの入れ物」です。

#### 📒 2.1.1 変数の宣言

- スクリプト上で変数に初めて値を格納したタイミグで、変数のための領域が自動的にメモリ上に確保される。

#### 📒 2.1.2 識別子の命令規則

1. Unicode 文字を利用できる(ただし、アンダースコア以外の記号、句読点、絵文字などは不可)
2. 1 文字目は数字以外であること
3. アルファベットの大文字／小文字は区別される。
4. 予約語でないこと
5. 文字数の制限はない

#### 📒 2.1.3 よりよい識別のためのルール

#### 📒 2.1.4. 変数の破棄

- del 命令を利用することで、宣言済みの変数を破棄することができる。

#### 📒 2.1.5. 定数

- あとから中身を変更できない入れ物のことを**定数**と呼ぶ
- Python 自体には定数という仕組みはない。すべて大文字の名前とすることで、一般的な変数と区別する。

#### 📒 2.2 データ型

- **データ型(型)**とは、データの種類のこと。
- Python はデータ型に対して寛容。(動的型付け)

#### 📒 2.2.1 データ型の種類

| 分類       | 型       | 概要                       | 変更可能 | 反復不可 | 順序 |
| :--------- | :------- | :------------------------- | :------- | :------- | :--- |
| 数値       | int      | 整数型                     | ×        | ×        | ×    |
| 数値       | float    | 浮動小数点型               | ×        | ×        | ×    |
| 数値       | complex  | 複素数型                   | ×        | ×        | ×    |
| データ     | str      | 文字列型                   | ×        | 〇       | 〇   |
| データ     | bytes    | バイナリデータ             | ×        | 〇       | 〇   |
| コンテナー | list     | 順序を持つリスト           | 〇       | 〇       | 〇   |
| コンテナー | tuple    | 順序を持つリスト(変更不可) | ×        | 〇       | 〇   |
| コンテナー | dict     | キー／値の辞書             | 〇       | 〇       | 〇   |
| コンテナー | set      | 順序を持たない値の集合     | 〇       | 〇       | ×    |
| その他     | bool     | 論理型(True または False)  | ×        | ×        | ×    |
| その他     | NoneType | 値がない                   | ×        | ×        | ×    |

#### 📒 2.2.2 論理型(bool)

- 論理型は、組み込み型の中でも、最も単純な型で、真(正しい)か偽(間違い)か、いずれの状態しか持ちません。
- True/False というキーワードで表現できます。
- Python では論理値を必要とする状況で以下を自動的に False とみなす。
  - 空値(None)
  - 数値のゼロ(0、0.0、0J など)
  - 文字列、空のリストなど(",(),[],set(),range(0)など)

#### 📒 2.2.3 整数型(int)

- 整数リテラル
  - 10 進数リテラル　・・・　-13, 108, 0
  - 16 進数リテラル　・・・　 0xff,0xA3C1
  - 8 進数リテラル　・・・　 0o666, 0o124
  - 2 進数リテラル　・・・　 0b1101, 0b100

#### 📒 2.2.4 浮動小数点(float)

- 一般的な小数点(1.41421356)のようなものだけではなく、指数表現が存在する
- **指数表現とは**
  - <仮数部> e <符号> <指数部>
  - <仮数部> x 10 の<符号><指数部>
    - <例> 1.4142e10 ➡ 1.414 x 10 の 10 乗
    - <例> 1.173205e-7 ➡ 1.173205 x 10 の -7 乗

#### 📒 2.2.5 数値セパレータ

- Python 3.6 以降では、桁数の大きな数値の可読性を改善するため、数値リテラルの中に桁区切り文字(\_)を記述する。
- **数詞セパレータ**
  - 例) value = 1_234_567

#### 📒 2.2.6 複素数型(Complex)

- 複素数(虚数)とは数学上の概念的な値で、
  - **<実部> + <虚部>j** の形式で表す。

#### 📒 2.2.7 文字列型(str)

- 文字列リテラルを表現するには、文字全体をシングルクォート(')、または、ダブルクォート(")でくくる。
- フォーマット文字列
  - Python3.6 以降では、文字列リテラルの先頭に「f」、または「F」をつけることで、文字列の中に{...}の形式で埋め込むことができる。

#### 📒 2.2.8 リスト(list)

- **リスト**には複数の値を収めることができる。リストとは仕切りのある入れ物だと考えてもよい。
- 仕切りで区切られたスペース(**要素**と言います)
- 言語によっては、**配列**(array)と呼ばれることもある。

## 📒 3. 演算子

- **演算子(オペレータ)**とは、与えられた変数やリテラルに対して、あらかじめ決められた処理を行う処理です。
- 演算子によって処理される変数／リテラルのことを**被演算子(オペランド)**と呼ぶ
- Python 演算子は大きく以下に分かれる。
  - 算術演算子
  - 代入演算子
  - 比較演算子
  - 論理演算子
  - ビット演算子

### 📒 3.1 算術演算子

- **代数演算子**ともいう。四則演算をはじめ、日常的な数学で利用する演算子を提供する。

| 演算子 | 概要               | 例              |
| :----- | :----------------- | :-------------- |
| +      | 加算               | 2 + 3 ➡ 5       |
| -      | 減算               | 5 -2 ➡ 3        |
| \*     | 乗算               | 2 \* 4 ➡ 8      |
| \*\*   | べき乗             | 2 \*\* 3 ➡ 8    |
| /      | 除算               | 7 / 3 ➡ 2.33... |
| //     | 除算(切り捨て)     | 7 // 2 ➡ 3      |
| %      | 剰余(割ったあまり) | 10 % 3 ➡ 1      |

### 📒 3.2 代入演算子

- 左辺で指定した変数に対して、右辺の値を設定(代入)するための演算子です。

| 演算子 | 概要                                                   | 例                        |
| :----- | :----------------------------------------------------- | :------------------------ |
| =      | 変数などに値を代入                                     | x = 10                    |
| +=     | 左辺と右辺を加算した結果を、左辺に代入                 | x = 5; x += 2 ➡ x = 7     |
| -=     | 左辺と右辺の差を、左辺に代入                           | x = 5; x -= 2 ➡ x = 3     |
| \*=    | 左辺と右辺の積を、左辺に代入                           | x = 5; x \*= 2 ➡ x = 10   |
| /=     | 左辺と右辺の商を、左辺に代入                           | x = 5; x /= 2 ➡ x = 2.5   |
| //=    | 左辺と右辺の商を、左辺に代入                           | x = 5; x //= 2 ➡ x = 2    |
| %=     | 左辺と右辺の商のあまりを、左辺に代入                   | x = 5; x %= 2 ➡ x = 1     |
| \*\*=  | 左辺と右辺のべき乗を、左辺に代入                       | x = 5; x \*\*= 2 ➡ x = 25 |
| &=     | ビット演算子の論理積(AND)した結果を左辺に代入          | x = 5; x &= 2 ➡ x = 0     |
| ^=     | ビット演算子の排他論理和(XOR)(XOR)した結果を左辺に代入 | x = 5; x ^= 2 ➡ x = 7     |
| \|=    | ビット演算子の論理和(OR)した結果を左辺に代入           | x = 5; x \|= 2 ➡ x = 7    |
| >>=    | ビット演算子の右シフトした結果を左辺に代入             | x = 5; x >>= 2 ➡ x = 1    |
| <<=    | ビット演算子の左シフトした結果を左辺に代入             | x = 5; x <<= 2 ➡ x = 20   |

#### 📒 3.2.4 アンパック代入

- **アンパック代入**とは、リスト／辞書などを分解し、配下の要素を個々の変数に分解する構文のこと。

```Python
data = [1, 2, 3, 4, 5]
a, b, c, d, e = data
print(a)
print(b)
print(c)
print(d)
print(e)

```

#### 📒 3.2.5 新しい代入演算子 「:=」

- Python でも代入「式」を書けるように、Python3.8 で導入されたのが「:=」演算子です。
- 横に倒れたセイウチの顔に似ていることから、セイウチ演算子とも呼ばれる。

```Python
y = (x := 20) / 10
```

#### 📒 3.3 比較演算子

- **比較演算子**は左辺と右辺を比較し、その結果を True/False として返す。

| 演算子   | 概要                                        | 例                       |
| :------- | :------------------------------------------ | :----------------------- |
| <        | 左辺が右辺より小さい場合に True             | 5 < 10 ➡ True            |
| >        | 左辺が右辺より大きい場合に True             | 5 > 10 ➡ False           |
| ==       | 左辺と右辺が等しい場合に True               | 5 == 5 ➡ True            |
| <=       | 左辺が右辺以下である場合に True             | 5 <= 10 ➡ True           |
| >=       | 左辺が右辺以上である場合に True             | 5 >= 10 ➡ False          |
| !=       | 左辺と右辺が等しくない場合に True           | 5 != 10 ➡ True           |
| is [not] | 左辺と右辺のオブジェクトが等しい場合に True | [1, 2] is [1, 2] ➡ False |
| [not] in | 左辺が右辺に含まれているか(いないか)        | 3 in [1, 2, 3] ➡ True    |

#### 📒 3.3.1 異なる型での比較

- 「＜」、「＞」などの大小比較では、異なる型同士での比較はエラーです。
- 対して、「==」「!=」演算子はことなる型同士でも比較できる。ただし、一般的には False を返す。

#### 📒 3.3.2 リストの比較

- リスト同士の比較にも、比較演算子は利用できる。リストの比較といっても、考え方は文字列のそれと同じです。
- 先頭から要素を比較していき、最初に異なる要素が見つかった場合に、その大小を決定する。

```Python
data1 = [1, 2, 3]
data2 = [1, 5]
data3 = [1, 2]

print(data1 < data2)
print(data1 < data3)
```

#### 📒 3.3.3 浮動小数点の比較

- 浮動小数点を比較にするには、以下のような方法を利用する。

  - (1) Decimal 型
    - Decimal 型は厳密な浮動小数点の演算/比較を可能にする
  - (2) 丸め単位による比較

    - 比較に限定するならば、以下のような方法も利用できる。

    ```Python
    EPSILON = 0.00001
    x = 0.2 * 3
    y = 0.6
    print(abs(x-y) < EPSILON)
    ```

  - (3) isclose 関数

    - math モジュールの isclose 関数を利用することで、(2)のよな近似比較をシンプルに表現できる
      - rel_to: 相対誤差。2 つの値のうち、絶対値の大きい値に対する割合で指定
      - abs_to: 絶対誤差。許容する誤差を絶対値で指定。

    ```Python
    import math

    print(math.isclose(0.2 * 3, 0.6))
    print(math.isclose(0.1, 0.1001, rel_tol=0.0001)) # False
    print(math.isclose(0.1, 0.1001, rel_tol=0.001)) # True

    ```

#### 📒 3.3.4 同一性と同値性

- 比較演算子を利用する上で、**同一性**と**同値性**を区別することは重要。
  - 同一性： 参照値が同じオブジェクトを参照していること
  - 同値性： オブジェクトが同じ値を持っていること

#### 📒 3.3.5 条件演算子

- **条件演算子**は指定された条件の真偽に応じて対応する式を返す。

### 📒 3.4 論理演算子

- **論理演算子**は複数の条件式を論理的に結合しその結果を True/False を返す。

| 演算子 | 概要                                                | 例              |
| :----- | :-------------------------------------------------- | :-------------- |
| and    | 論理積。左右の式がともに True の場合に True         | x and y ➡ False |
| or     | 論理和。左右の式のどちらかが True の場合に True     | x or y ➡ True   |
| ^      | 排他論理和。左右の式が異なる場合に True             | x ^ y ➡ True    |
| not    | 否定。式が True の場合は False、False の場合は True | not x ➡ False   |

#### 📒 3.4.1 ショートカット演算(短絡演算)

- 論理積/論理和演算では、「ある条件のもとにでは、左式だけが評価されて右式が評価されない」場合がある。このような演算のことを**ショートカット演算**、あるいは**短絡演算**と呼ぶ。

#### 📒 3.4.2 比較演算子の連結

- Python は比較演算子の連結を認めているため、以下のような記載ができる

```Python
50 <= x <= 100
```

### 📒 3.5 ビット演算子

- **ビット演算**とは、整数を 2 進数で表したときの各桁(ビット単位)を論理計算する演算のことです。

| 演算子    | 概要                                                            | 例                                 |
| :-------- | :-------------------------------------------------------------- | :--------------------------------- |
| &         | 論理積。左式/右式の双方にセットされているビットをセット         | 10 & 1 ➡ 1010 & 0001 ➡ 0000 ➡ 0    |
| \|        | 論理和。左式/右式のどちらかがセットされているビットをセット     | 10 \| 1 ➡ 1010 \| 0001 ➡ 1011 ➡ 11 |
| ^         | 排他論理和。左式/右式のどちらかがセットされているビットをセット | 10 ^ 1 ➡ 1010 ^ 0001 ➡ 1011 ➡ 11   |
| ~(チルダ) | 否定。ビットを反転                                              | ~10 ➡ ~1010 ➡ 0101 ➡ -11           |
| <<        | ビットを左にシフト                                              | 10 << 1 ➡ 1010 << 1 ➡ 10100 ➡ 20   |
| >>        | ビットを右にシフト                                              | 10 >> 1 ➡ 1010 >> 1 ➡ 101 ➡ 5      |

### 📒 3.6 演算子の優先順位と結合則

- 式に複数の演算子が含まれている場合、これらがどのよな順序で処理されるかを知っておくことは重要。
- このルールを規定したおのが、演算子の**優先順位**と**結合則**です。

## 📒 4. 制御構文

- 一般的に、プログラムの構造は以下のように分類できる。
  - **順次(順接)**: 記述されら順番に処理を実行
  - **選択**: 条件によって処理を分岐
  - **反復**: 特定の処理を繰り返し実行

### 📒 4.1 条件分岐

- 実際のアプリケーションでは、ユーザーからの入力や実行環境、その他の条件に応じて、処理を切り替えるのが一般的です。

#### 📒 4.1.1 if 命令 - 単純分岐

- if は、与えられた条件が True/False いずれかによって、実行すべき処理を決める命令です。

```Python
# if 命令
if 条件式:
  ...条件式がTrueのときに実行する処理...
else:
  ...条件式がFalseのときに実行する処理...
```

#### 📒 4.1.2 if 命令 - 多岐分岐

- elif ブロックを利用することで、多岐分岐を表現できる。

```Python
if 条件式1:
  ...条件式1がTrueのときに実行する処理...
elif 条件式2:
  ...条件式2がTrueのときに実行する処理...
else
  ...すべての条件式がFalseのときに実行する処理...

```

#### 📒 4.1.3 if 命令 - 入れ子の構造

```Python
i = 0
j = 0

if i == 1:
    if j == 1:
        print("変数i,jは1です。")
    else:
        print("変数iは1ですが、jは1ではありません。")
else:
    print("変数iは1ではありません。")

```

#### 📒 4.1.4 補足 条件式を指定する場合の注意

#### 📒 4.1.5 match...case 命令 (Python3.10)

- match..case 構文は与えられた式と値を比較しマッチしたブロックを選択的に実行する。

```Python
match 式:
  case パターン1:
    ...「式」と「パターン1」がマッチした場合に実行する処理...
  case パターン2:
    ...「式」と「パターン2」がマッチした場合に実行する処理...
  ...
```

### 📒 4.2 繰り返し処理

- Python では、while/for といった繰り返し処理が用意されており、条件式、リスト、指定回数などに基づいて繰り返し処理を実行できる。

#### 📒 4.2.1 条件式が True の間だけ処理を繰り返す - while 命令

- while 命令を利用することで、条件式が True である間だけ、配下の処理を繰り返すことができる。

```Python
while 条件式:
  ...条件式がTrueのときに実行する処理...

```

#### 📒 4.2.2 リストの内容を順に処理する - for 命令

- for 命令を利用することで、リスト／辞書などから順に要素を取り出し、決められた処理を実行することできる。

```Python
for 仮変数 in list:
  ...個々の要素を処理するコード...

```

#### 📒 4.2.3 決められた回数だけ処理を実行する。 - for 命令(range 関数)

- リストを擬似的に作成し(range 関数)で、決められた回数だけ処理を実行する。

```Python
for i in range(1, 6):
    print(f"{i}番目のループです。")
```

#### 📒 4.2.4 リストから新たなリストを生成する - リスト内包表記

- **内包表記**とは、既存のリストから新たなリストを生成する際に簡単に書ける表現方法です。

```Python
[式 for 仮変数 in リスト]
```

### 📒 4.3 ループの制御

- while／for 命令ではいずれも、あらかじめ決められた終了条件を満たしたタイミングで、ループを終了します。
- 処理によっては特定の条件を満たしたところで、強制的にループを中断したい、あるいは特定の周回だけスキップしたいこともある。
- Python では break/continue というループ制御構文が用意されている。

#### 📒 4.3.1 ループを中断する - break 命令

- break 命令を使用すると、for/while 本来の終了条件にかかわらず、繰り返し処理を中断できる。

```Python
sum = 0

for i in range(1, 101):
    sum += i
    if sum > 1000:
        break

print(f"合計が10000を超えるのは、1～{i}を加算したときです。")

```

#### 📒 4.3.2 現在の周回をスキップする - continue 命令

- 現在の周回だけをスキップし、ループそのものは継続して実行するのが、continue 命令の役割です。

```Python
sum = 0

for i in range(1, 101):
    if i % 2 != 0:
        continue
    sum += i

print(f"合計値は{sum}です。")

```

#### 📒 4.3.3 ループでの終了処理を実行する。

- Python では、else 節を while/for 命令でも利用できる。while/for 節の else 節は
  - **break せずにループを終了した場合に実行する処理**を表す。

#### 📒 4.3.4 入れ子のループ中断／スキップする

### 📒 4.4 例外処理

- アプリ開発していくと、さまざまな問題(エラー)に遭遇する。エラーはさらに、**アプリとして事前に対処できるかどうか**によって以下の 2 種類に大別できる。
  - (1) 構文エラー
  - (2) 例外

#### 📒 4.4.1 例外処理をする - try 命令

- 例外処理とは、あらかじめ発生する**かもしれない**エラーを想定しておき、実行を継続できるように処理する。

```Python
try:
  ...例外が発生するかもしれないコード...
except 例外の種類 as 例外変数:
  ...例外発生時の処理...
```

#### 📒 4.4.2 例外が発生した場合、しなかった場合の処理を定義する

- try ... except 構文では、後処理を行う節として、else/finally を用意している。

```Python
try:
  ...例外が発生するかもしれないコード...
except 例外の種類 as 例外変数:
  ...例外発生時の処理...
else:
  ...例外が発生しなかったときの処理...
finally:
  ...例外の有無にかかわらず実行する処理...
```

## 📒 5. 標準ライブラリ

- Python では、標準的な言語機能に加えて、コードから自在に呼び出させる命令(群)をあまた提供している。このような命令を**ライブライ**と呼び、Python を学ぶ場合には、ライブラリの用法も含めて理解が欠かせない。

### 📒 5.1 ライブラリの分類

- Python では、さまざま形でライブラリを提供されている。
- ライブラリを提供している機能は、大まかに以下の観点から分類できる。
  - (1) 型と関数
  - (2) 組み込みライブラリとモジュール

#### 📒 5.1.1 関数

**関数**とは、何かしら入力(パラメーター)を与えることによって、あらかじめ決まった処理を行い、その結果を返す仕組みのこと。

- 関数への入力のことを**引数**
- 出力のこととを**戻り値**

#### 📒 5.1.2 型

- **型(データ)**は、コードの中で扱える値の種類を決めるための仕組みです。
- 型をより専門的な用語では**クラス**という。
- 型に対して具体的な値を与えて、コードの中で利用できるようにすることを**インスタンス化**と呼ぶ。
- クラスメソッド／クラス変数に対して、インスタンス経由で呼び出すメソッド／変数のことを**インスタンスメソッド**、**インスタンス変数**と呼ぶ
  - インスタンスメソッド／変数は、インスタンスの情報を取得／操作するためのもの
  - クラスメソッド／変数は、クラスの情報を取得／操作するもの

#### 📒 5.1.3 組み込み型／関数とモジュール

- モジュールに属する型、関数を利用する際には、まず対象のモジュールを読み込む必要がある。
- これを**インポート**と言う。インポートには、import という命令を利用する。

```Python
import モジュール名
```

- **特定のメンバーだけをインポートする**
  - 「import module」では、モジュール内のすべてのメンバーをインポートする。
  - from ... import 命令を利用することで、モジュール内の特定の関数／クラス(型)だけをインポートすることもできる。

```Python
from module import member ...

module: モジュール名
member: 関数/クラス名
```

### 📒 5.2 文字列の操作

#### 📒 5.2.1 文字列の長さを取得する

- 文字列の長さを取得するには、組み込み関数の len を利用する。
- len 関数では、日本語(マルチバイト文字)も正しく 1 文字としてカウントする。
- もしも半角を 1 文字、全角を 2 文字としてカウントしたいならば、unicodedata モジュールの east_asian_width 関数を利用する。

#### 📒 5.2.2 文字列の大文字 ⇔ 小文字で変換

- 文字列の大文字／小文字に変換するメソッドには以下のようなものがある。
  |メソッド|概要|
  |:---|:---|
  |lower()|大文字 ➡ 小文字に変換|
  |upper()|小文字 ➡ 大文字に変換|
  |swapcase()|大文字と小文字を反転|
  |capitalize()|先頭文字を大文字に、以降を小文字に変換|
  |title()|単語の先頭文字を大文字に、それ以降を小文字に変換|
  |casefold()|大文字小文字の区別を除去|

#### 📒 5.2.3 部分文字列を取得する

- 文字列から部分的な文字列を取り出すには、インデックス／スライス構文を利用する。

```Python
txt[index]
txt[start:end:step]

txt: 文字列
index: インデックス番号
start: 開始位置
end: 終了位置
step: ステップ(増減)
```

#### 5.2.4 文字の種類を判定する

- 文字列に含まれる文字の種類を判定するには、isxxxxx メソッドを利用する。
  |メソッドの種類|概要|
  |:---|:---|
  |isalnum()|英数字であるか|
  |isalpah()|英字であるか|
  |isascii()|ASCII 文字であるか|
  |isdecimal()|10 進数値であるか|
  |isdigit()|数値であるか|
  |isnumeric()|数値文字であるか|
  |isidentifier()|有効な識別子であるか|
  |islower()|小文字であるか|
  |isupper()|大文字であるか|
  |istitle()|単語の先頭文字だけが大文字であるか|
  |isprintable()|印字可能な文字か否か|
  |isspace()|空白文字であるか|
- **文字列を数値に変換する**
  - unicodedata モジュールの digit/numeric 関数を利用する
- **予約済みの識別子を確認する**
  - isidentifier メソッドは与えられた文字列が識別子として認められている文字のみで構成されているかを判定する。
  - 文字列が予約済みの識別子であるか判定する場合、keyword モジュールの iskeyword 関数を利用する。

#### 📒 5.2.5 文字列を検索する

- 特定の文字列が登場する文字位置を取得するには、find/rfind メソッドを利用する。

```Python
s.find(sub ,[start, end])
s.rfind(sub, [start, end]])

s: 元の文字列
sub: 検索文字列
start: 検索開始位置
end: 検索終了位置

```

- **例外を返す index/rindex メソッド**
  - 検索文字列が見つからなかった場合に例外(ValueError)を返すのが index/rindex メソッド。
  - 構文は find/rfind メソッドと同じ。
- **部分文字列の登場回数をカウントする**
  - 文字位置を検索する find/index メソッドに対して、count メソッドを利用することで、部分文字列が登場する回数をカウントすることもできる。

```Python
s.count(sub, [start, end])
s: 元の文字列
sub: 検索文字列
start: 検索開始位置
end: 検索終了位置
```

#### 📒 5.2.6 文字列の前後から空白を除去する

- strip/lstrip/rstrip メソッドを利用することで、文字列前後の空白を除去できる。
  - strip メソッドは前後の双方の空白
  - lstrip は前方だけ
  - rstrip は後方だけ

```Python
s.strip([chars])
s.lstrip([chars])
s.rstrip([chars])

s: 元の文字列
chars: 除去する文字群
```

#### 📒 5.2.7 文字列に特定の文字列が含まれているか判定する

- 文字列の指定された部分文字列が含まれるかを判定するには、in 演算子を利用する。
- ある文字列が先頭／末尾に位置するかを判定するならば、startswith/endswith メソッドも利用できる。

```Python
substr in s
s.startswith(prefix[, start[,entd]])
s.endswith(suffix[, start[, end]])

s: 元の文字列
substr/prefix/suffix: 検索文字列
start: 検索開始位置
end: 検索終了位置

```

#### 📒 5.2.8 文字列を特定の区切り文字で分割する

- **一般的な分割 split／rsplit**

```Python
s.split(sep=None, maxspilt=-1)
s.rsplit(sep=None, maxsplit=-1)

s: 元の文字列
sep: 区切り文字列
maxsplit: 最大分割数

```
