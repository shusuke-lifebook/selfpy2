# 📒 独習 Python 第 2 版

## 📒 第 1 章 イントロダクション

### 📒 1.1.5 Python ライブラリ

- Python は「Battery Included」(電池付きで、そのまま使える)という思想もとので設計されており、このライブラリが標準で贅沢に用意されている。
- [PyPI(Python Package Index)](https://pypi.org)
  - 拡張ライブラリの集積場ともいうべきサービス

### 📒 1.2.2 Python 開発の状況

- Python の実装には PyPy、IronPython、Jython などがあるが、中でも有名は実装が**CPython**である。
- 非営利団体である[**Python ソフトウェア財団**](https://www.python.org/psf/)が管理している。[オープンソース](https://github.com/python/cpython/)として提供される。

## 📒 第 2 章 Python の基礎

### 📒 2.1 変数

**変数**とは一言で表すと「データの入れ物」です。

#### 📒 2.1.1 変数の宣言

- スクリプト上で変数に初めて値を格納したタイミグで、変数のための領域が自動的にメモリ上に確保される。

#### 📒 2.1.2 識別子の命令規則

1. Unicode 文字を利用できる(ただし、アンダースコア以外の記号、句読点、絵文字などは不可)
2. 1 文字目は数字以外であること
3. アルファベットの大文字／小文字は区別される。
4. 予約語でないこと
5. 文字数の制限はない

#### 📒 2.1.3 よりよい識別のためのルール

#### 📒 2.1.4. 変数の破棄

- del 命令を利用することで、宣言済みの変数を破棄することができる。

#### 📒 2.1.5. 定数

- あとから中身を変更できない入れ物のことを**定数**と呼ぶ
- Python 自体には定数という仕組みはない。すべて大文字の名前とすることで、一般的な変数と区別する。

#### 📒 2.2 データ型

- **データ型(型)**とは、データの種類のこと。
- Python はデータ型に対して寛容。(動的型付け)

#### 📒 2.2.1 データ型の種類

| 分類       | 型       | 概要                       | 変更可能 | 反復不可 | 順序 |
| :--------- | :------- | :------------------------- | :------- | :------- | :--- |
| 数値       | int      | 整数型                     | ×        | ×        | ×    |
| 数値       | float    | 浮動小数点型               | ×        | ×        | ×    |
| 数値       | complex  | 複素数型                   | ×        | ×        | ×    |
| データ     | str      | 文字列型                   | ×        | 〇       | 〇   |
| データ     | bytes    | バイナリデータ             | ×        | 〇       | 〇   |
| コンテナー | list     | 順序を持つリスト           | 〇       | 〇       | 〇   |
| コンテナー | tuple    | 順序を持つリスト(変更不可) | ×        | 〇       | 〇   |
| コンテナー | dict     | キー／値の辞書             | 〇       | 〇       | 〇   |
| コンテナー | set      | 順序を持たない値の集合     | 〇       | 〇       | ×    |
| その他     | bool     | 論理型(True または False)  | ×        | ×        | ×    |
| その他     | NoneType | 値がない                   | ×        | ×        | ×    |

#### 📒 2.2.2 論理型(bool)

- 論理型は、組み込み型の中でも、最も単純な型で、真(正しい)か偽(間違い)か、いずれの状態しか持ちません。
- True/False というキーワードで表現できます。
- Python では論理値を必要とする状況で以下を自動的に False とみなす。
  - 空値(None)
  - 数値のゼロ(0、0.0、0J など)
  - 文字列、空のリストなど(",(),[],set(),range(0)など)

#### 📒 2.2.3 整数型(int)

- 整数リテラル
  - 10 進数リテラル　・・・　-13, 108, 0
  - 16 進数リテラル　・・・　 0xff,0xA3C1
  - 8 進数リテラル　・・・　 0o666, 0o124
  - 2 進数リテラル　・・・　 0b1101, 0b100

#### 📒 2.2.4 浮動小数点(float)

- 一般的な小数点(1.41421356)のようなものだけではなく、指数表現が存在する
- **指数表現とは**
  - <仮数部> e <符号> <指数部>
  - <仮数部> x 10 の<符号><指数部>
    - <例> 1.4142e10 ➡ 1.414 x 10 の 10 乗
    - <例> 1.173205e-7 ➡ 1.173205 x 10 の -7 乗

#### 📒 2.2.5 数値セパレータ

- Python 3.6 以降では、桁数の大きな数値の可読性を改善するため、数値リテラルの中に桁区切り文字(\_)を記述する。
- **数詞セパレータ**
  - 例) value = 1_234_567

#### 📒 2.2.6 複素数型(Complex)

- 複素数(虚数)とは数学上の概念的な値で、
  - **<実部> + <虚部>j** の形式で表す。

#### 📒 2.2.7 文字列型(str)

- 文字列リテラルを表現するには、文字全体をシングルクォート(')、または、ダブルクォート(")でくくる。
- フォーマット文字列
  - Python3.6 以降では、文字列リテラルの先頭に「f」、または「F」をつけることで、文字列の中に{...}の形式で埋め込むことができる。

#### 📒 2.2.8 リスト(list)

- **リスト**には複数の値を収めることができる。リストとは仕切りのある入れ物だと考えてもよい。
- 仕切りで区切られたスペース(**要素**と言います)
- 言語によっては、**配列**(array)と呼ばれることもある。

## 📒 3. 演算子

- **演算子(オペレータ)**とは、与えられた変数やリテラルに対して、あらかじめ決められた処理を行う処理です。
- 演算子によって処理される変数／リテラルのことを**被演算子(オペランド)**と呼ぶ
- Python 演算子は大きく以下に分かれる。
  - 算術演算子
  - 代入演算子
  - 比較演算子
  - 論理演算子
  - ビット演算子

### 📒 3.1 算術演算子

- **代数演算子**ともいう。四則演算をはじめ、日常的な数学で利用する演算子を提供する。

| 演算子 | 概要               | 例              |
| :----- | :----------------- | :-------------- |
| +      | 加算               | 2 + 3 ➡ 5       |
| -      | 減算               | 5 -2 ➡ 3        |
| \*     | 乗算               | 2 \* 4 ➡ 8      |
| \*\*   | べき乗             | 2 \*\* 3 ➡ 8    |
| /      | 除算               | 7 / 3 ➡ 2.33... |
| //     | 除算(切り捨て)     | 7 // 2 ➡ 3      |
| %      | 剰余(割ったあまり) | 10 % 3 ➡ 1      |

### 📒 3.2 代入演算子

- 左辺で指定した変数に対して、右辺の値を設定(代入)するための演算子です。

| 演算子 | 概要                                                   | 例                        |
| :----- | :----------------------------------------------------- | :------------------------ |
| =      | 変数などに値を代入                                     | x = 10                    |
| +=     | 左辺と右辺を加算した結果を、左辺に代入                 | x = 5; x += 2 ➡ x = 7     |
| -=     | 左辺と右辺の差を、左辺に代入                           | x = 5; x -= 2 ➡ x = 3     |
| \*=    | 左辺と右辺の積を、左辺に代入                           | x = 5; x \*= 2 ➡ x = 10   |
| /=     | 左辺と右辺の商を、左辺に代入                           | x = 5; x /= 2 ➡ x = 2.5   |
| //=    | 左辺と右辺の商を、左辺に代入                           | x = 5; x //= 2 ➡ x = 2    |
| %=     | 左辺と右辺の商のあまりを、左辺に代入                   | x = 5; x %= 2 ➡ x = 1     |
| \*\*=  | 左辺と右辺のべき乗を、左辺に代入                       | x = 5; x \*\*= 2 ➡ x = 25 |
| &=     | ビット演算子の論理積(AND)した結果を左辺に代入          | x = 5; x &= 2 ➡ x = 0     |
| ^=     | ビット演算子の排他論理和(XOR)(XOR)した結果を左辺に代入 | x = 5; x ^= 2 ➡ x = 7     |
| \|=    | ビット演算子の論理和(OR)した結果を左辺に代入           | x = 5; x \|= 2 ➡ x = 7    |
| >>=    | ビット演算子の右シフトした結果を左辺に代入             | x = 5; x >>= 2 ➡ x = 1    |
| <<=    | ビット演算子の左シフトした結果を左辺に代入             | x = 5; x <<= 2 ➡ x = 20   |

#### 📒 3.2.4 アンパック代入

- **アンパック代入**とは、リスト／辞書などを分解し、配下の要素を個々の変数に分解する構文のこと。

```Python
data = [1, 2, 3, 4, 5]
a, b, c, d, e = data
print(a)
print(b)
print(c)
print(d)
print(e)

```

#### 📒 3.2.5 新しい代入演算子 「:=」

- Python でも代入「式」を書けるように、Python3.8 で導入されたのが「:=」演算子です。
- 横に倒れたセイウチの顔に似ていることから、セイウチ演算子とも呼ばれる。

```Python
y = (x := 20) / 10
```

#### 📒 3.3 比較演算子

- **比較演算子**は左辺と右辺を比較し、その結果を True/False として返す。

| 演算子   | 概要                                        | 例                       |
| :------- | :------------------------------------------ | :----------------------- |
| <        | 左辺が右辺より小さい場合に True             | 5 < 10 ➡ True            |
| >        | 左辺が右辺より大きい場合に True             | 5 > 10 ➡ False           |
| ==       | 左辺と右辺が等しい場合に True               | 5 == 5 ➡ True            |
| <=       | 左辺が右辺以下である場合に True             | 5 <= 10 ➡ True           |
| >=       | 左辺が右辺以上である場合に True             | 5 >= 10 ➡ False          |
| !=       | 左辺と右辺が等しくない場合に True           | 5 != 10 ➡ True           |
| is [not] | 左辺と右辺のオブジェクトが等しい場合に True | [1, 2] is [1, 2] ➡ False |
| [not] in | 左辺が右辺に含まれているか(いないか)        | 3 in [1, 2, 3] ➡ True    |

#### 📒 3.3.1 異なる型での比較

- 「＜」、「＞」などの大小比較では、異なる型同士での比較はエラーです。
- 対して、「==」「!=」演算子はことなる型同士でも比較できる。ただし、一般的には False を返す。

#### 📒 3.3.2 リストの比較

- リスト同士の比較にも、比較演算子は利用できる。リストの比較といっても、考え方は文字列のそれと同じです。
- 先頭から要素を比較していき、最初に異なる要素が見つかった場合に、その大小を決定する。

```Python
data1 = [1, 2, 3]
data2 = [1, 5]
data3 = [1, 2]

print(data1 < data2)
print(data1 < data3)
```

#### 📒 3.3.3 浮動小数点の比較

- 浮動小数点を比較にするには、以下のような方法を利用する。
  - (1) Decimal 型
    - Decimal 型は厳密な浮動小数点の演算/比較を可能にする
  - (2) 丸め単位による比較
    - 比較に限定するならば、以下のような方法も利用できる。

    ```Python
    EPSILON = 0.00001
    x = 0.2 * 3
    y = 0.6
    print(abs(x-y) < EPSILON)
    ```

  - (3) isclose 関数
    - math モジュールの isclose 関数を利用することで、(2)のよな近似比較をシンプルに表現できる
      - rel_to: 相対誤差。2 つの値のうち、絶対値の大きい値に対する割合で指定
      - abs_to: 絶対誤差。許容する誤差を絶対値で指定。

    ```Python
    import math

    print(math.isclose(0.2 * 3, 0.6))
    print(math.isclose(0.1, 0.1001, rel_tol=0.0001)) # False
    print(math.isclose(0.1, 0.1001, rel_tol=0.001)) # True

    ```

#### 📒 3.3.4 同一性と同値性

- 比較演算子を利用する上で、**同一性**と**同値性**を区別することは重要。
  - 同一性： 参照値が同じオブジェクトを参照していること
  - 同値性： オブジェクトが同じ値を持っていること

#### 📒 3.3.5 条件演算子

- **条件演算子**は指定された条件の真偽に応じて対応する式を返す。

### 📒 3.4 論理演算子

- **論理演算子**は複数の条件式を論理的に結合しその結果を True/False を返す。

| 演算子 | 概要                                                | 例              |
| :----- | :-------------------------------------------------- | :-------------- |
| and    | 論理積。左右の式がともに True の場合に True         | x and y ➡ False |
| or     | 論理和。左右の式のどちらかが True の場合に True     | x or y ➡ True   |
| ^      | 排他論理和。左右の式が異なる場合に True             | x ^ y ➡ True    |
| not    | 否定。式が True の場合は False、False の場合は True | not x ➡ False   |

#### 📒 3.4.1 ショートカット演算(短絡演算)

- 論理積/論理和演算では、「ある条件のもとにでは、左式だけが評価されて右式が評価されない」場合がある。このような演算のことを**ショートカット演算**、あるいは**短絡演算**と呼ぶ。

#### 📒 3.4.2 比較演算子の連結

- Python は比較演算子の連結を認めているため、以下のような記載ができる

```Python
50 <= x <= 100
```

### 📒 3.5 ビット演算子

- **ビット演算**とは、整数を 2 進数で表したときの各桁(ビット単位)を論理計算する演算のことです。

| 演算子    | 概要                                                            | 例                                 |
| :-------- | :-------------------------------------------------------------- | :--------------------------------- |
| &         | 論理積。左式/右式の双方にセットされているビットをセット         | 10 & 1 ➡ 1010 & 0001 ➡ 0000 ➡ 0    |
| \|        | 論理和。左式/右式のどちらかがセットされているビットをセット     | 10 \| 1 ➡ 1010 \| 0001 ➡ 1011 ➡ 11 |
| ^         | 排他論理和。左式/右式のどちらかがセットされているビットをセット | 10 ^ 1 ➡ 1010 ^ 0001 ➡ 1011 ➡ 11   |
| ~(チルダ) | 否定。ビットを反転                                              | ~10 ➡ ~1010 ➡ 0101 ➡ -11           |
| <<        | ビットを左にシフト                                              | 10 << 1 ➡ 1010 << 1 ➡ 10100 ➡ 20   |
| >>        | ビットを右にシフト                                              | 10 >> 1 ➡ 1010 >> 1 ➡ 101 ➡ 5      |

### 📒 3.6 演算子の優先順位と結合則

- 式に複数の演算子が含まれている場合、これらがどのよな順序で処理されるかを知っておくことは重要。
- このルールを規定したおのが、演算子の**優先順位**と**結合則**です。

## 📒 4. 制御構文

- 一般的に、プログラムの構造は以下のように分類できる。
  - **順次(順接)**: 記述されら順番に処理を実行
  - **選択**: 条件によって処理を分岐
  - **反復**: 特定の処理を繰り返し実行

### 📒 4.1 条件分岐

- 実際のアプリケーションでは、ユーザーからの入力や実行環境、その他の条件に応じて、処理を切り替えるのが一般的です。

#### 📒 4.1.1 if 命令 - 単純分岐

- if は、与えられた条件が True/False いずれかによって、実行すべき処理を決める命令です。

```Python
# if 命令
if 条件式:
  ...条件式がTrueのときに実行する処理...
else:
  ...条件式がFalseのときに実行する処理...
```

#### 📒 4.1.2 if 命令 - 多岐分岐

- elif ブロックを利用することで、多岐分岐を表現できる。

```Python
if 条件式1:
  ...条件式1がTrueのときに実行する処理...
elif 条件式2:
  ...条件式2がTrueのときに実行する処理...
else
  ...すべての条件式がFalseのときに実行する処理...

```

#### 📒 4.1.3 if 命令 - 入れ子の構造

```Python
i = 0
j = 0

if i == 1:
    if j == 1:
        print("変数i,jは1です。")
    else:
        print("変数iは1ですが、jは1ではありません。")
else:
    print("変数iは1ではありません。")

```

#### 📒 4.1.4 補足 条件式を指定する場合の注意

#### 📒 4.1.5 match...case 命令 (Python3.10)

- match..case 構文は与えられた式と値を比較しマッチしたブロックを選択的に実行する。

```Python
match 式:
  case パターン1:
    ...「式」と「パターン1」がマッチした場合に実行する処理...
  case パターン2:
    ...「式」と「パターン2」がマッチした場合に実行する処理...
  ...
```

### 📒 4.2 繰り返し処理

- Python では、while/for といった繰り返し処理が用意されており、条件式、リスト、指定回数などに基づいて繰り返し処理を実行できる。

#### 📒 4.2.1 条件式が True の間だけ処理を繰り返す - while 命令

- while 命令を利用することで、条件式が True である間だけ、配下の処理を繰り返すことができる。

```Python
while 条件式:
  ...条件式がTrueのときに実行する処理...

```

#### 📒 4.2.2 リストの内容を順に処理する - for 命令

- for 命令を利用することで、リスト／辞書などから順に要素を取り出し、決められた処理を実行することできる。

```Python
for 仮変数 in list:
  ...個々の要素を処理するコード...

```

#### 📒 4.2.3 決められた回数だけ処理を実行する。 - for 命令(range 関数)

- リストを擬似的に作成し(range 関数)で、決められた回数だけ処理を実行する。

```Python
for i in range(1, 6):
    print(f"{i}番目のループです。")
```

#### 📒 4.2.4 リストから新たなリストを生成する - リスト内包表記

- **内包表記**とは、既存のリストから新たなリストを生成する際に簡単に書ける表現方法です。

```Python
[式 for 仮変数 in リスト]
```

### 📒 4.3 ループの制御

- while／for 命令ではいずれも、あらかじめ決められた終了条件を満たしたタイミングで、ループを終了します。
- 処理によっては特定の条件を満たしたところで、強制的にループを中断したい、あるいは特定の周回だけスキップしたいこともある。
- Python では break/continue というループ制御構文が用意されている。

#### 📒 4.3.1 ループを中断する - break 命令

- break 命令を使用すると、for/while 本来の終了条件にかかわらず、繰り返し処理を中断できる。

```Python
sum = 0

for i in range(1, 101):
    sum += i
    if sum > 1000:
        break

print(f"合計が10000を超えるのは、1～{i}を加算したときです。")

```

#### 📒 4.3.2 現在の周回をスキップする - continue 命令

- 現在の周回だけをスキップし、ループそのものは継続して実行するのが、continue 命令の役割です。

```Python
sum = 0

for i in range(1, 101):
    if i % 2 != 0:
        continue
    sum += i

print(f"合計値は{sum}です。")

```

#### 📒 4.3.3 ループでの終了処理を実行する。

- Python では、else 節を while/for 命令でも利用できる。while/for 節の else 節は
  - **break せずにループを終了した場合に実行する処理**を表す。

#### 📒 4.3.4 入れ子のループ中断／スキップする

### 📒 4.4 例外処理

- アプリ開発していくと、さまざまな問題(エラー)に遭遇する。エラーはさらに、**アプリとして事前に対処できるかどうか**によって以下の 2 種類に大別できる。
  - (1) 構文エラー
  - (2) 例外

#### 📒 4.4.1 例外処理をする - try 命令

- 例外処理とは、あらかじめ発生する**かもしれない**エラーを想定しておき、実行を継続できるように処理する。

```Python
try:
  ...例外が発生するかもしれないコード...
except 例外の種類 as 例外変数:
  ...例外発生時の処理...
```

#### 📒 4.4.2 例外が発生した場合、しなかった場合の処理を定義する

- try ... except 構文では、後処理を行う節として、else/finally を用意している。

```Python
try:
  ...例外が発生するかもしれないコード...
except 例外の種類 as 例外変数:
  ...例外発生時の処理...
else:
  ...例外が発生しなかったときの処理...
finally:
  ...例外の有無にかかわらず実行する処理...
```

## 📒 5. 標準ライブラリ

- Python では、標準的な言語機能に加えて、コードから自在に呼び出させる命令(群)をあまた提供している。このような命令を**ライブライ**と呼び、Python を学ぶ場合には、ライブラリの用法も含めて理解が欠かせない。

### 📒 5.1 ライブラリの分類

- Python では、さまざま形でライブラリを提供されている。
- ライブラリを提供している機能は、大まかに以下の観点から分類できる。
  - (1) 型と関数
  - (2) 組み込みライブラリとモジュール

#### 📒 5.1.1 関数

**関数**とは、何かしら入力(パラメーター)を与えることによって、あらかじめ決まった処理を行い、その結果を返す仕組みのこと。

- 関数への入力のことを**引数**
- 出力のこととを**戻り値**

#### 📒 5.1.2 型

- **型(データ)**は、コードの中で扱える値の種類を決めるための仕組みです。
- 型をより専門的な用語では**クラス**という。
- 型に対して具体的な値を与えて、コードの中で利用できるようにすることを**インスタンス化**と呼ぶ。
- クラスメソッド／クラス変数に対して、インスタンス経由で呼び出すメソッド／変数のことを**インスタンスメソッド**、**インスタンス変数**と呼ぶ
  - インスタンスメソッド／変数は、インスタンスの情報を取得／操作するためのもの
  - クラスメソッド／変数は、クラスの情報を取得／操作するもの

#### 📒 5.1.3 組み込み型／関数とモジュール

- モジュールに属する型、関数を利用する際には、まず対象のモジュールを読み込む必要がある。
- これを**インポート**と言う。インポートには、import という命令を利用する。

```Python
import モジュール名
```

- **特定のメンバーだけをインポートする**
  - 「import module」では、モジュール内のすべてのメンバーをインポートする。
  - from ... import 命令を利用することで、モジュール内の特定の関数／クラス(型)だけをインポートすることもできる。

```Python
from module import member ...

module: モジュール名
member: 関数/クラス名
```

### 📒 5.2 文字列の操作

#### 📒 5.2.1 文字列の長さを取得する

- 文字列の長さを取得するには、組み込み関数の len を利用する。
- len 関数では、日本語(マルチバイト文字)も正しく 1 文字としてカウントする。
- もしも半角を 1 文字、全角を 2 文字としてカウントしたいならば、unicodedata モジュールの east_asian_width 関数を利用する。

#### 📒 5.2.2 文字列の大文字 ⇔ 小文字で変換

- 文字列の大文字／小文字に変換するメソッドには以下のようなものがある。
  |メソッド|概要|
  |:---|:---|
  |lower()|大文字 ➡ 小文字に変換|
  |upper()|小文字 ➡ 大文字に変換|
  |swapcase()|大文字と小文字を反転|
  |capitalize()|先頭文字を大文字に、以降を小文字に変換|
  |title()|単語の先頭文字を大文字に、それ以降を小文字に変換|
  |casefold()|大文字小文字の区別を除去|

#### 📒 5.2.3 部分文字列を取得する

- 文字列から部分的な文字列を取り出すには、インデックス／スライス構文を利用する。

```Python
txt[index]
txt[start:end:step]

txt: 文字列
index: インデックス番号
start: 開始位置
end: 終了位置
step: ステップ(増減)
```

#### 📒 5.2.4 文字の種類を判定する

- 文字列に含まれる文字の種類を判定するには、isxxxxx メソッドを利用する。
  |メソッドの種類|概要|
  |:---|:---|
  |isalnum()|英数字であるか|
  |isalpah()|英字であるか|
  |isascii()|ASCII 文字であるか|
  |isdecimal()|10 進数値であるか|
  |isdigit()|数値であるか|
  |isnumeric()|数値文字であるか|
  |isidentifier()|有効な識別子であるか|
  |islower()|小文字であるか|
  |isupper()|大文字であるか|
  |istitle()|単語の先頭文字だけが大文字であるか|
  |isprintable()|印字可能な文字か否か|
  |isspace()|空白文字であるか|
- **文字列を数値に変換する**
  - unicodedata モジュールの digit/numeric 関数を利用する
- **予約済みの識別子を確認する**
  - isidentifier メソッドは与えられた文字列が識別子として認められている文字のみで構成されているかを判定する。
  - 文字列が予約済みの識別子であるか判定する場合、keyword モジュールの iskeyword 関数を利用する。

#### 📒 5.2.5 文字列を検索する

- 特定の文字列が登場する文字位置を取得するには、find/rfind メソッドを利用する。

```Python
s.find(sub ,[start, end])
s.rfind(sub, [start, end]])

s: 元の文字列
sub: 検索文字列
start: 検索開始位置
end: 検索終了位置

```

- **例外を返す index/rindex メソッド**
  - 検索文字列が見つからなかった場合に例外(ValueError)を返すのが index/rindex メソッド。
  - 構文は find/rfind メソッドと同じ。
- **部分文字列の登場回数をカウントする**
  - 文字位置を検索する find/index メソッドに対して、count メソッドを利用することで、部分文字列が登場する回数をカウントすることもできる。

```Python
s.count(sub, [start, end])
s: 元の文字列
sub: 検索文字列
start: 検索開始位置
end: 検索終了位置
```

#### 📒 5.2.6 文字列の前後から空白を除去する

- strip/lstrip/rstrip メソッドを利用することで、文字列前後の空白を除去できる。
  - strip メソッドは前後の双方の空白
  - lstrip は前方だけ
  - rstrip は後方だけ

```Python
s.strip([chars])
s.lstrip([chars])
s.rstrip([chars])

s: 元の文字列
chars: 除去する文字群
```

#### 📒 5.2.7 文字列に特定の文字列が含まれているか判定する

- 文字列の指定された部分文字列が含まれるかを判定するには、in 演算子を利用する。
- ある文字列が先頭／末尾に位置するかを判定するならば、startswith/endswith メソッドも利用できる。

```Python
substr in s
s.startswith(prefix[, start[,entd]])
s.endswith(suffix[, start[, end]])

s: 元の文字列
substr/prefix/suffix: 検索文字列
start: 検索開始位置
end: 検索終了位置

```

#### 📒 5.2.8 文字列を特定の区切り文字で分割する

- **一般的な分割 split／rsplit**

```Python
s.split(sep=None, maxspilt=-1)
s.rsplit(sep=None, maxsplit=-1)

s: 元の文字列
sep: 区切り文字列
maxsplit: 最大分割数

```

- **改行文字で分割する --splitlines メソッド**
- **区切り文字で文字列を 2 分割する**

#### 📒 5.2.9 リストを結合する

- リストは、join メソッドを利用することで、指定の区切り文字で連結できます。

```Python
joinメソッド

s.join(iterable)

s:区切り文字
iterable: 連結対象のリスト
```

#### 📒 5.2.10 文字列を置き換える

- 文字列に含まれる特定の部分文字列を別の文字に置き換えるには、replace メソッドを利用する。

```Python
s.replace(old, new[, count])
s: 元の文字列
old: 置き換える部分文字列
new: 置き換え後の文字列
count: 置き換える個数
```

- **特定の文字を変換／削除する**
  - 表記をそろえるなどの目的で、文字列に含まれる特定の文字(群)を変換／削除したいというケースがある
  - replace よりも translate メソッドを利用することをお勧めする
  - translate メソッドは引数に変換ルールを受け取る。変換ルールを作成するのは、str.maketrans メソッドを利用する。

  ```Python
  str.maketrans(dict)
  str.maketrans(old, new[, no])

  dict:「変換前：変換後」の辞書
  old: 変換前の文字群
  new: 変換後の文字群
  no: 除去する文字群
  ```

#### 📒 5.2.11 文字を整形する

- format メソッドを利用することで、指定された書式文字列に基づいて文字列を整形できる。

```Python
txt.format(*args, **kwargs)

txt: 書式文字列
args: 書式に割り当てる値(可変変数)
kwargs: 書式に割り当てる値(キーワード引数)
```

#### 📒 5.2.12 str 型 ⇔bytes 型を変換する

- Python では、受け渡しのためのエンコーディング情報を管理しており、その情報に基づいて文字列をエンコード変換している。
- 文字列を別のアプリとやりとりするようになると、文字エンコーディングを意識して明示的にエンコードしなければならない状況がでる。これを行うのが、encode メソッドです。

```Python
txt.encode(encoding='utf-8', errors="strict")

txt: 任意の文字列
encoding: 変換に利用するエンコーディング
errors: エラー時の挙動
```

- Python で bytes 型の値を str 型に戻すには、decode メソッドを利用する

```Python
bs.decode(encoding='utf-8', errors="strict")

bs: 任意のバイト列
encoding: 変換に利用するエンコーディング
errors: エラー時の挙動
```

| 設定値  | 概要                                           |
| :------ | :--------------------------------------------- |
| strict  | エラー(例外)を発生させて処理を中止             |
| ignore  | 変換できない文字は除去して、そのまま処理を継続 |
| replace | 変換できない文字は「?」などに置換              |

### 5.3 日付/時刻の操作

- 組み込まれていないもので、アプリ開発でよく利用するのが日付／時刻値です。
- Python で日付／時刻値を扱うには、datetime モジュールを利用するのが基本です。
  |型|概要|
  |:---|:---|
  |datetime|日付／時刻値|
  |date|日付値|
  |time|時刻値|
  |timezone|タイムゾーン情報|
  |timedelta|時間間隔|

#### 📒 5.3.1 日付／時刻値を生成する。

- datetime モジュールは日付／時刻値を生成／初期化するために様々な方法を用意している。
  |メソッド|概要|
  |:---|:--|
  |datetime.today()|現在の日時|
  |date.today()|今日の日付|
  |datetime.now()|現在の日時(タイムゾーン付き)|

```Python
timezone(ofset)
ofset: 時差(timedelta型)

ZoneInfo(key)
key: タイムゾーンの名前

```

- **指定された年月日、時分秒から生成する**
  - datetime/date/time 型は、それぞれ以下のようにインスタンス化できる。

  ```Python
  datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)
  date(year, month, day)
  time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None)

  year: 年
  month: 月
  day: 日
  hour: 時
  minute: 分
  second: 秒
  microsecond: マイクロ秒
  tzinfo: タイムゾーン情報
  fold: 夏季時間を加味するか
  ```

- **日付／時刻を文字列から変換する**
  - strptime メソッドを利用することで、文字列から日付／時刻値を datetime オブジェクトを生成できる。

  ```Python
  datetime.strptime(date_string, format)

  date_string: 日付文字列
  format: 解析に利用する書籍
  ```

- **タイムスタンプから生成する**

```Python
datetime.fromtimestamp(timestamp, tz=None)
date.fromtimestamp(timestamp)

timestamp: タイムスタンプ値
tz: タイムゾーン
```

- **一部の要素を書き換えた日付を生成する**

```Python
dt.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzionfo, *, fold=0)
dat.replace(year=self.year, month=self.month, day=self.day)
tim.replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, *, fold=0)

dt: datetimeオブジェクト
dat: dateオブジェクト
tim: timeオブジェクト
year: 年
month: 月
day: 日
hour: 時
minute: 分
second: 秒
microsecond: マイクロ秒
tzinfo: タイムゾーン
fold: 夏季時間を加味するか
```

#### 📒 5.3.2 年月日、時分秒などの時刻要素を取得する

| 属性        | 概要                     |
| :---------- | :----------------------- |
| year        | 年                       |
| month       | 月(1 ～ 12)              |
| day         | 日(1 ～ 31)              |
| hour        | 時(0 ～ 23)              |
| minute      | 分(0 ～ 59)              |
| second      | 秒(0 ～ 59)              |
| microsecond | マイクロ秒(0 ～ 999999)  |
| tzinfo      | タイムゾーン(timezon 型) |

| メソッド      | 概要                                                         |
| :------------ | :----------------------------------------------------------- |
| date()        | 日付部分を取得                                               |
| time()        | 時刻部分を取得(native)                                       |
| timetz()      | 時刻部分を取得(aware)                                        |
| timestamp()   | タイムスタンプ値を取得                                       |
| toordinal()   | 西暦 1 年 1 月 1 日からの通算日                              |
| weekend()     | 曜日を取得(0:月～ 6:日)                                      |
| isoweekday()  | 曜日を取得(1:月～ 7:日)                                      |
| isocalender() | (year=年,week=週番号,weekday=曜日)形式の名前付きタプルを取得 |

#### 📒 5.3.3 日付／時刻値を加算／減算する

```Python
dt + delta
dt - delta

dt: 日付／時刻値(datetime/date/time)
delta: 加算／減算する時間(timedelta)
```

```Python
timedelta(days=0, weeks=0, hours=0, minutes=0, seconds=0, microseconds=0, millseconds=0)

days: 日数
weeks: 週数
hours: 時間数
minutes: 分数
seconds: 秒数
microseconds: マイクロ秒数
millseconds: ミリ秒数
```

#### 📒 5.3.4 日付／時刻値の差分を求める

- datetime/date/time 同士では「-」演算を利用することで、互いの差を求めることができる。

```Python
dt1 - dt2

dt1/dt2: 日付／時刻値(datetime／date／time)
```

#### 📒 5.3.5 日付／時刻値を比較する

- 「<」「>」などの比較演算子を利用することで、日付／時刻のいずれかの過去／未来かを判定することが可能

#### 📒 5.3.6 日付／時刻を整形する

- 日付／時刻値を整形するには、strftime メソッドを利用する。

```Python
dt.strftime(format)

dt: 日付／時刻値(datetime/date/time)
format: 書式文字列
```

- strftime メソッドはロケール(地域)情報によって変動する。最初に setlocale メソッドで明示的にロケールを設定する。

```Python
setlocale(category, locale=None)

category: 設定する対象
locale: ロケール値
```

#### 📒 5.3.7 カレンダーを生成する

- カレンダーの生成に特化した calender モジュールを利用して生成する。

## 📒 6. 標準ライブラリ

- 型の中でも複数の値を束ねるための仕組みを持つものを相称して、**コレクション、コンテナー**などと呼ぶ
  - シーケンス型
    - インデックスで管理
    - 値の重複は OK
  - セット(集合)型
    - 順番は持たない
    - 値の重複は NG
  - 辞書(マッピング)型
    - キーと値のペアで管理
    - キーの重複は NG

### 📒 6.1 シーケンス型

- リスト(list)
- タプル(tuple)
- レンジ(range)

#### 📒 6.1.1 リストの生成

1. list リテラル
2. リスト内包表記
3. list コンストラクタ
4. リストを返す関数／メソッド(sorted 関数、split 関数など)

```Python
list([iterable])

iterable: イテラブル型
```

#### 📒 6.1.2 リストから特定の範囲の要素を取得する - スライス構文

- リストから特定の範囲の要素を取り出すには、スライス構文を利用する。

```Python
lists[start:end:step]

lists: リスト
start: 開始位置
end: 終了位置
step: ステップ(増減)
```

#### 📒 6.1.3 リストの要素数を取得する

- len 関数でリストに含まれる要素の数を取得できる。

```Python
len(list)

list: 対象のリスト
```

#### 📒 6.1.4 リストに要素を追加／削除する

- リストに要素を追加／削除するには以下のようなメソッドを利用する

```Python
append／insert／popメソッド

lists.append(x) ➡ 末尾に追加
lists.insert(i, x) ➡ i番目の直前に追加
lists.pop([i]) ➡ i番目を削除

lists: 任意のリスト
x: 追加する値
i: 挿入／削除箇所を表すインデックス番号
```

- **スタック構造**
  - **スタック**とは、**後入れ先出し** または **先入れ後出し**と呼ばれる構造

#### 📒 6.1.5 リスト内の要素を削除する

- リストから指定された要素を削除するには remove メソッドを、すべての要素を削除するには clear メソッドを利用する。

```Python
lists.remove(x)
lists.clear()

lists: 任意のリスト
x: 削除する要素
```

#### 📒 6.1.6 複数要素を追加／置換／削除する

- スライス構文を利用することでリストの任意の場所に要素を追加したり、既存の要素を置き換えたり、あるいは削除したりといったコードを短いコードで実施できる。

```Python
data = ["あ", "い", "う", "え", "お"]
data[1:3] = ["1", "2", "3"]
# data[2:4] = []
# del data[2:4]
# data[1:1] = ['1', '2', '3']
# data[1:1] = '987'
print(data)

```

#### 📒 6.1.7 リストを検索する

- リストの中で特定の要素が登場するインデックス位置を取得するには、index メソッドを利用する。

```Python
lists.index(elem[,start[,end]])

lists: 任意のリスト
elem: 検索する要素
start: 検索開始位置
end: 検索終了位置
```

- **要素の登場回数をカウントする**
  - count メソッドを利用することで、同一の要素が登場する回数をカウントすることができる

```Python
list.count(elem)

lists: 任意のリスト
elem: 検索する要素
```

- **要素の有無を確認する**
  - 要素の有無を確認するだけであれば、in 演算子を利用する。

#### 📒 6.1.8 リストを複製する

- copy メソッドで利用して複製することできる
- **シャローコピー**
  - copy メソッドは**シャローコピー**、配下の要素がミュータブルである場合、コピー先の変更はコピーもとに影響する
- **ディープコピー**
  - copy モジュールの deepcopy 関数を利用する。

#### 📒 6.1.9 リストを連結する

- リストを連結するには、文字列と同じく「+」「\*」演算子を利用する
- 既存のリストを拡張する
  - 「+」「\*」演算子は新たなリストを生成するが、既存のリストに対して、要素を連結したいという場合がある。これは extend メソッドを利用する。(または +=)

#### 📒 6.1.10 リストの内容を並び替える

- sort／reverse メソッドなどを利用する
- 並びを逆順にする
  - 並びを逆順にするだけであれば、reverse メソッドを利用する。
  - reverse メソッドと reversed 関数の違い
    - reverse メソッドが現在のリストに影響を及ぼすに対して、reserved 関数は逆順に並び替えた結果を戻り値として返す。
    - reversed 関数の戻り値はリストではなく、イテレーター
- **リストを昇順／降順にソートする**

```Python
lists.sort(*, key=None, reversed=False)

lists: 任意のリスト
key: ソートに利用するキー
reverse: 逆順にソートするか
```

- **任意のキーで並べ替える**
  - sortメソッドのkeyオプションを利用することで、独自のルールで並べ変えることができる。
  - 例えば、リストを文字数について昇順にする。
- **ソート順を保ちながら要素を挿入する -bisect-**
  - ソート順を保ちながら要素を挿入する場合、要素を挿入するたび、sortメソッドしなおしても構いません
  - 挿入するコードが増えれば面倒かつ抜けの原因となる。
  - bisectモジュールを利用することで、リストの順序を保ちながら新規の要素を挿入できる。
  - bisectとは、**配列二分法アルゴリズムの意味**

  ```Python
  insort(a, x, *, key=None)

  a: 対象のリスト
  x: 挿入する値
  key: ソートに利用するキー
  ```

#### 📒 6.1.11 リストをforループで処理する方法

- enumerate／zipなどを利用したより複雑なリスト処理を紹介する
  - **インデックス番号／値をセットで取り出す**
    - enumerate関数を併用することで、値とインデックス番号を取り出しながらループが可能になる。

      ```Python
      data = ["ぱんだ", "うさぎ", "こあら", "とら"]

      for index, value in enumerate(data):
        print(index, ":", value)
      ```

  - **複数のリストを纏めて処理する**
    - zip関数を利用することで、複数のリストを束ねて処理することが可能

      ```Python
      data1 = ["ぱんだ", "うさぎ", "こあら", "とら"]
      data2 = ["panda", "rabbit", "koala"]

      for d1, d2 in zip(data1, data2):
        print(d1, "=", d2)
      ```

    - **最も要素数の多いリストに合わせて処理する**
      - 最も要素数の多いリストに合わせて処理するばらば、itertoolsモジュールのzip_longest関数を利用する

        ```Python
        import itertools

        data1 = ["ぱんだ", "うさぎ", "こあら", "とら"]
        data2 = ["panda", "rabbit", "koala"]

        for d1, d2 in itertools.zip_longest(data1, data2):
            print(d1, ":", d2)

        ```

#### 📒 6.1.12 リスト内の要素がTrueであるか

- リスト内の要素がTrueであるかを判定するには以下を利用する
  |関数|概要|
  |:---|:---|
  |all(list)|リスト内のすべての要素がTrueであるか|
  |any(list)|リスト内の要素が1つでもTrueであるか|
  |not all(list)|リスト内の要素が1つでもFalseであるか|
  |not any(list)|リスト内のすべての要素がFalseであるか|

#### 📒 6.1.13 リスト内の要素を加工する

- 組み込み関数mapを利用することで、リストから順に要素を取得&加工し、新たなリストを生成する

```Python
map(function, iterable, ...)

function: 要素を加工する処理
iterable: 処理対象のリスト
```

#### 📒 6.1.14 リストの内容を特定の条件で絞り込む

- 組む込み関数filterを利用することで、リストの内容を関数で判定し、その中でTrueと判定された要素だけ取得できる

```Python
filter(function, iterable)

function: 要素のTrue／Falseを判定する処理
iterable: 処理対象のリスト
```

#### 📒 6.1.15 リスト内の要素を順に処理して1つにまとめる

- functoolsモジュールのreduce関数を利用する

```Python
reduce(function, iterable[, initalizer])

function: 要素を演算する処理
iterable: 処理対象のリスト
initializer: 初期値
```

#### 📒 6.1.16 キュー構造を実装する

- キュー(Queue)は、先入れ先出し(FIFO)と呼ばれるデータ構造です。
- 最初に入った要素から順に処理する流れが窓口などでサービスを待つ様子にも似ていることから、**待ち行列**とも呼ばれる
- キュー構造を実装するならば、collections.deque型を利用することを勧める。

```Python
dquer([iterable[, maxlen]])

iteralbe: 元なるデータ(リストなど)
maxlen: 最大長
```

| メソッド      | 概要                  |
| :------------ | :-------------------- |
| append(x)     | 値を末尾に追加        |
| appendleft(x) | 値を先頭に追加        |
| clear()       | すべての値を破棄      |
| pop()         | 末尾から値を取得&削除 |
| popleft()     | 先頭から値を取得&削除 |

#### 📒 6.1.17 イミュータブルなリストを生成する

- **タプル(tuple)**とは、「変更できない(イミュータブル)なリスト」です。

### 📒 6.2 セット(集合)型

- セット(Set)は、リストと違って順番を持たない
- 重複した値も許さない。
- セット
  - set: ミュータブル
  - fronzenset: イミュターブル

#### 📒 6.2.1 セットの生成

```Python
set([iterable])

iterable: セットに収納するリスト／タプルなど
```

- **入れ子のセットを宣言**
  - セットの要素はイミュターブル(より正しくはハッシュ可能)でなければならない。値が一定でなければ重複も判定できないのは当然
  - 入れ子のセットを表現する場合
    - **内側のセットはfrozensetでなけらばならない**

#### 📒 6.2.2 セットの基本操作

-

#### 📒 6.2.3 要素の有無／包含関係を判定する

- 一般的にセットを利用するのは、ある値がすでに存在するか？
- あるセットが別のセットに含まれているか？
- 集合関係に関心がある場合になるでしょう。

- 「<」演算子も利用できるが、こちらは真部分集合を意味する。つまり、「あるセットが別のセットに含まれるが、等しくない」を判定する。

```Python
sets.issubset(other)

sets: 任意のセット
other: 比較のセット
```

- 逆に、セットsetsに別のotherが含まれるかを判定したいならば、issupersetメソッドを利用する

```Python
sets.issuperset(other)

sets: 任意のセット
other: 比較のセット
```

#### 📒 6.2.4 和集合／差集合／積集合などを求める

- | (union: 和集合)
- & (intersection: 積集合)
- \- (difference: 差集合)
- ^ (sysmatic_difference: 対称差集合)

- セット内包表記

```Python
{式 for 仮変数 in イテラブル型 if 条件式}
```

### 📒 6.3 辞書(dict)型

- **辞書(dict)**は、一意のキーと値をペアで管理されるデータ構造。言語によっては**ハッシュ、連想配列**と呼べれる場合もある。

#### 📒 6.3.1 辞書の生成

- 様々な方法で辞書を作成してみよう

```Python
d1 = {"red": "赤", "white": "白", "yellow": "黄"}
print(d1)
d2 = {}
print(d2)
d3 = dict(red="赤", white="白", yellow="黄")
print(d3)
d4 = dict([("red", "赤"), ("white", "白"), ("yellow", "黄")])
print(d4)
d5 = dict({"yellow": "黄", "white": "白", "red": "赤"})
print(d5)
d6 = dict({"red": "赤", "white": "白", "yellow": "黄"}, white="白", black="黒")
print(d6)
d7 = dict(zip(["red", "white", "yellow"], ["赤", "白", "黄"]))
print(d7)
```

#### 📒 6.3.2 ハッシュ表とキーの注意点

- dict(辞書)は内部的に**ハッシュ表(ハッシュテーブル)**と呼ばれるリストを持つ
  - **キーはハッシュ可能であること**
    - 辞書(dict)のキーは、ハッシュ値を算出可能な型でなければならない。このような性質を**hashable(ハッシュ可能)**と呼ぶ
    - 組み込み型では以下のような型がhashableです。
      - int
      - str
      - bytes
      - tuple
      - frozenset

#### 📒 6.3.3 辞書の基本操作

- 辞書の操作方法は、リスト／セットのそれを理解していれば、ごく直観的にわかる。
  - **辞書にキー／値を設定する**
    - 辞書に後からキー／値を追加する場合、ブラケット構文、または、setdefaultメソッドを利用する。
      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      d["apple"] = "林檎"
      d["strawberry"] = "いちご"
      print(d.setdefault("apple", "〇"))
      print(d.setdefault("watermelon", "〇"))
      print(d)
      ```
  - **辞書に複数のキー／値を設定する**
    - 複数のキー／値をまとめて設定するならば、updateメソッドを利用できる
      ```Python
      d1 = {"apple": "りんご", "orange": "みかん"}
      d2 = {"melon": "メロン", "orange": "蜜柑"}
      d1.update(d2)
      print(d1)
      d1.update(strawberry="いちご", watermelon="スイカ")
      print(d1)
      d1.update([("pear", "なし"), ("grape", "ぶどう")])
      print(d1)
      ```
  - **辞書から値を取得する**
    - 辞書から値を取得するには、ブラケット構文をはじめ、get、pop／popitemメソッドが利用できる。
      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      # print(d["pear"])  # エラー KeyError: 'pear'
      print(d.get("pear", "×"))
      print(d.pop("melon", "×"))
      print(d.popitem())
      print(d)
      ```
  - **特定のキーが含まれているかを判定する**
    - 値ではなく、単にキーが存在するかどうかを判定したいだけであれば、in演算子を利用する
      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      print("orange" in d)
      print("pear" in d)
      ```
  - **辞書からキーを削除する**
    - del命令で個別のキーを削除し、clearメソッドですべてのキーを破棄する。
      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      del d["orange"]
      print(d)
      d.clear()
      print(d)
      ```
  - **辞書の内容を列挙する**
    - dictの内容を列挙するには以下のようなメソッドを利用する

      | メソッド | 概要                   |
      | :------- | :--------------------- |
      | items()  | キー／値のビューを取得 |
      | keys()   | キーのビューを取得     |
      | values() | 値のビューを取得       |

      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      # 項目を列挙
      for item in d.items():
          print(item)

      for key, value in d.items():
          print(key, ":", value)

      # キーを列挙
      for key in d.keys():
          print(key)

      # 値を列挙
      for value in d.values():
          print(value)
      ```

  - **辞書のキーを比較する**
    - keysメソッドの戻り値は、セットと同じく、「&」「|」などの演算子を用いることで積集合や和集合を求めることができる
      ```Python
      d1 = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      d2 = {"grape": "ぶどう", "orange": "蜜柑", "pear": "なし", "apple": "林檎"}
      print(d1.keys() & d2.keys())
      ```
  - **複数の辞書を結合する**
    - 辞書そのものに対して、「|」(論理和)の演算子を用いた場合は、複数の辞書を結合できる。
      ```Python
      d1 = {"apple": "りんご", "melon": "メロン"}
      d2 = {"grape": "ぶどう", "pear": "なし", "apple": "林檎"}
      print(d1 | d2)
      print(d2 | d1)
      ```
  - **規定値を持つ辞書を定義する ----defaultdict**
    - リストdataに含まれるそれぞれの名前の出現数をカウントするためのコード

      ```Python
      data = ["太郎", "花子", "次郎", "太郎", "太郎", "太郎", "花子"]
      result = {}

      for key in data:
          if key in result:
              result[key] += 1
          else:
              result[key] = 1

      print(result)
      ```

    - いちいち初期化の判定をするのが面倒に思える。collectionsモジュールのdefaultdict型を利用する

      ```Python
      from collections import defaultdict

      data = ["太郎", "花子", "次郎", "太郎", "太郎", "太郎", "花子"]
      result = defaultdict(int)

      for key in data:
          result[key] += 1

      print(result)

      ```

      ```Python
      defaultdictコンストラクター

      defaultdict(factory[,args])

      factory: 規定値を生成する関数
      args: dictコンストラクター相当の引数
      ```

#### 📒 6.3.5 辞書内包表記

- リスト内包表記／セット内包表記と同様、辞書でも内包表記を利用できる

  ```Python
  {キー： 値 for 仮変数 in イテラブル if 条件式}
  ```

  ```Python
  d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
  result = {value: key for key, value in d.items()}
  print(result)
  ```

#### 📒 6.3.6 辞書型でのパターンマッチング

- パターンマッチングは辞書型に対しても用いることができる(**マッピングパターン**)

  ```Python
  # 書籍情報を表す辞書
  book = {
      "isbn": "978-4-7981-8055-7",
      "title": "独習 ASP.NET Core",
      "publisher": "翔泳社",
      "price": 4290,
      "page": 672,
  }

  # 記事情報を表す辞書
  article = {
      "url": "https://codezine.jp/article/corner/1009",
      "title": "「GitHub Copilot」 入門",
      "time": 8,
  }

  match book:
      case {"isbn": _, "title": title, "publisher": publisher}:
          print(f"{title} ({publisher}刊)")
      case {"url": url, "title": title}:
          print(f"{title} ({url})")
      case _:
          print("コンテンツの種類が不明です。")
  ```

- **複数のキーをまとめてキャプチャーする**
  - 「\*\*変数」で、指定されなかったキーをまとめてキャプチャすることもできる

    ```Python
    # 書籍情報を表す辞書
    book = {
        "isbn": "978-4-7981-8055-7",
        "title": "独習 ASP.NET Core",
        "publisher": "翔泳社",
        "price": 4290,
        "page": 672,
    }

    match book:
        case {"isbn": _, "title": title, **info}:
            print(f"{title} ({info})")
        case {"url": url, "title": title}:
            print(f"{title} ({url})")
    ```

## 📒 7. 標準ライブラリ

- 正規表現
- ファイルの操作
- HTTP通信
- 数学演算など

### 📒 7.1 正規表現

- **正規表現**とは「あいまいな文字列パターンを表現する記法」です。

#### 📒 7.1.1 正規表現の基本

- 正規表現によって表されたある文字列パターンのことを**正規表現パターン**という。ある文字列の中に含まれる場合、文字列が正規表現パターンに**マッチする**と言います。

#### 📒 7.1.2 文字列が正規表現パターンにマッチしたかを判定する

```Python
import re

msg = "電話番号は080-111-9999です。"
# 正規表現の準備
ptn = re.compile(r"(\d{2,4})-(\d{2,4})-(\d{4})")
# 文字列を検索&結果を表示
if result := ptn.search(msg):
    print(result.group(0))
    print(result.group(1))
    print(result.group(2))
    print(result.group(3))
else:
    print("見つかりませんでした。")
```

- 正規表現を利用するには、まず、reモジュールのcompile関数で正規表現を準備する。

  ```Python
  compile(pattern, flags=0)

  pattern: 正規表現パターン
  flags: 正規表現オプション
  ```

  ```Python
  ptn.search(string[, pos, [endpos]])

  ptn: Patternオブジェクト
  string: 検索対象の文字列
  pos: 検索開始位置
  endpos: 検索終了位置
  ```

  | メソッド／属性      | 概要                                                    |
  | :------------------ | :------------------------------------------------------ |
  | group([group, ...]) | group番目にマッチした部分文字を取得                     |
  | start([group])      | 開始位置を取得                                          |
  | end([group])        | 終了位置を取得                                          |
  | span([group])       | 「開始位置,終了位置」形式のタプルを取得                 |
  | expand(templ)       | マッチした結果をテンプレートtemplに埋め込んだ結果を取得 |
  | pos                 | 検索時に指定された開始位置                              |
  | endpos              | 検索時に指定された終了位置                              |
  | lastindex           | 最後にマッチしたインデックス                            |
  | lastgroup           | 最後にマッチしたグループの名前                          |

#### 📒 7.1.3 マッチしたすべての文字列を取得する

- search/matchメソッドで得られる結果は、いずれも最初にマッチした文字列1つだけ、もしもマッチした文字列をすべて取得したいなら、findall/finditerメソッドを利用する

```Python
ptn.findall(string[,pos[,endopos]])
ptn.finditer(string[,pos[,endopos]])

ptn: Patternオブジェクト
string: 文字列
pos: 検索開始位置
endpos: 検索終了位置
```

#### 📒 7.1.4 正規表現オプションでマッチング時の挙動を制御する

- Patternクラスをインスタンス化する際には、第2引数に検索オプション(マッチフラグ)を渡すこともできる。

  | 設定値        | 概要                                                       |
  | :------------ | :--------------------------------------------------------- |
  | IGNORECASE、I | 大文字小文字を区別しない                                   |
  | MULTILINE、M  | 複数行モードの有効化                                       |
  | DOTALL、S     | 「.」が行末記号を含む任意の文字にマッチ(単一行モード)      |
  | VERBOSE、X    | 空白とコメントを有効化                                     |
  | ASCII、A      | \w/\W、\b/\B、\d/\D、\s/\SでASCII文字に限定したマッチ【1】 |
  | LOCALE、L     | \w、\Wなどをロケールに従って処理                           |

- **大文字／小文字を区別しない**

  ```Python
  import re

  msg = "仕事はwings@example.comです。プライベート用はYAMA@example.comです。"
  ptn = re.compile(
      r"[a-z0-9.!#$%&\'*+/=?^_{|}~-]+@[a-z0-9-]+(\.[a-z0-9-]+)*", re.IGNORECASE
  )
  results = ptn.finditer(msg)
  for result in results:
      print(result.group())
  ```

- **マルチラインモードを有効にする**
  - **マルチラインモード(複数行)**とは「^」「$」の挙動を変更するためのモードです。

    ```Python
    import re

    msg = "10人のインディアン。\n1年生になったら"
    ptn = re.compile(r"^\d*", re.MULTILINE)
    results = ptn.findall(msg)
    for result in results:
        print(result)
    ```

  - **シングルラインモードを有効にする**
    - **シングルラインモード**とは、「.」の挙動を変更するためのモードです。

      ```Python
      import re

      msg = "初めまして。\nよろしくお願いします。"
      ptn = re.compile(r"^.+", re.DOTALL)
      results = ptn.findall(msg)
      for result in results:
          print(result)
      ```

  - **正規表現を見やすく整形する**
    - re.VERBOSEフラグを有効にすることで、正規表現パターンに空白／コメントを付与できるようになる。

      ```Python
      import re

      msg = "仕事用はwings@example.comです。プライベート用はYAMA@example.comです。"
      ptn = re.compile(
          r"""[a-z0-9.!#$%&'*+/=?^_{|}~-]+ # local
                          @                            # delimiter
                          [a-z0-9-]+(\.[a-z0-9-]+)*    # domain """,
          re.IGNORECASE | re.VERBOSE,
      )

      results = ptn.finditer(msg)
      for result in results:
          print(result.group())
      ```

  - **埋め込み**
    - **インラインフラグ(埋め込みフラグ)**として指定することができる

      | フラグ | オプション |
      | :----- | :--------- |
      | ?i     | IGNORECASE |
      | ?m     | MULTILINE  |
      | ?s     | DOTALL     |
      | ?x     | VERBOSE    |
      | ?a     | ASCII      |
      | ?L     | LOCALE     |

#### 📒 7.1.5 正規表現による検索

- **最長一致と最短一致**
  - **最長一致**とは正規表現で「\*」「+」などの量指定子を利用した場合に、できるだけ長い文字列に一致させなさい。というルール
  - **最短一致**は「+?」で、できるだけ短い文字列に一致させようとする。同じく「\*?」「{n,}?」「??」などの最短一致表現も可能
- **名前付きキャプチャーグループ**
  - 正規表現パターンに含まれる(...)でくくられた部分のことを、グループ、またはキャプチャグループという。
  - このグループに名前を付与することができる。これを**名前付きキャプチャーグループ**という
- **グループの後方参照**
  - グループにマッチした文字列は、正規表現パターンの中で後から参照することができる(**後方参照**)
- **参照されないグループ**
  - (?:...)とすることで、サブマッチの対象から除外できる。
- **後読みと先読み**
  - 正規表現では、前後の文字列の有無によって、本来の文字列がマッチするかを判定する表現がある。

    | 表現    | 概要                                                     |
    | :------ | :------------------------------------------------------- |
    | A(?=B)  | 肯定的先読み (Aの直後にBが続く場合にだけ、Aにマッチ)     |
    | A(?!B)  | 否定的先読み (Aの直後にBが続かない場合にだけ、Aにマッチ) |
    | (?<=B)A | 肯定的後読み (Aの直後にBがある場合にだけ、Aにマッチ)     |
    | (?<!B)A | 否定的後読み (Aの直後にBがない場合だけ、Aにマッチ)       |

#### 📒 7.1.6 正規表現で文字列を置き換える

- subメソッドを用いれば、正規表現にマッチした文字列を置き換えることができる

  ```Python
  ptn.sub(repl, string, count=0)

  ptn: Patternオブジェクト
  repl: 置き換え後の文字列
  string: 置き換え対象の文字列
  count: 置き換えの最大工数
  ```

  ```Python
  import re

  msg = "サポートサイトはhttps://www.wings.msn.to/ です。"
  ptn = re.compile(r"http(s)?://([\w-]+\.)+[\w-]+(/[\w./?%&=-]*)?", re.IGNORECASE)
  print(ptn.sub(r'<a href="\g<0>">\g<0></a>', msg))

  ```

  | 変数  | 格納されている値          |
  | :---- | :------------------------ |
  | \g<0> | https://www.wings.msn.to/ |
  | \g<1> | s                         |
  | \g<2> | msn.                      |
  | \g<3> | /                         |

- **名前付きキャプチャグループの例**
  - subメソッドでも名前付きキャプチャグループを利用できる。

    ```Python
    import re

    msg = "仕事用はwings@example.comです。"

    ptn = re.compile(
        r"(?i)(?P<localName>[a-z0-9.!#$%&\'*+/=?^_{|}~-]+)\@"
        r"(?P<domain>[a-z0-9-]+(?:\.[a-z0-9-]+)*)"
    )
    print(ptn.sub(r"\g<domain>の\g<localName>", msg))

    ```

#### 📒 7.1.7 正規表現で文字列を分割する

- 正規表現で文字を分割するには、splitメソッドを利用する

  ```Python
  ptn.split(string, maxsplit=0)

  ptn: Patternオブジェクト
  string: 分割対象の文字列
  maxsplit: 最大の分割数
  ```

### 📒 7.2 ファイル操作

- open関数を利用して、テキストファイルを読み書き
- バイナリファイル、CSVファイルなど特殊な形式のファイルの操作方法

#### 📒 7.2.1 テキストファイルへの書き込み

- 日付をテキストファイルに記録する例

  ```Python
  from datetime import datetime

  file = open("./chap07/access.log", "a", encoding="UTF-8")
  file.write(f"{datetime.now()}\n")
  file.close()
  print("現在時刻をファイルに保存しました。")
  ```

- ファイル操作の基本
  - ファイルを開く(open)
    - open関数

      ```Python
      open(file, mode="r", encoding=None)

      file: ファイルパス
      mode: オープンモード
      encoding: 文字エンコーディング名
      ```

    - 主なオープンモード

    | モード | 概要                                                                   |
    | :----- | :--------------------------------------------------------------------- |
    | r      | 読み込み専用(ファイルが存在しなければエラー)                           |
    | r+     | 読み書き両用(ファイルが存在しなければエラー)                           |
    | w      | 書き込み専用(ファイルが存在しなければ新規作成)                         |
    | w+     | 読み書き専用(ファイルの内容をクリア。ファイルが存在しなければ新規作成) |
    | a      | 追記専用(ファイルが存在する場合は末尾に追記)                           |
    | a+     | 読み書き両用(既存の内容に追記。ファイルが存在しなければ新規作成)       |
    | x      | 書き込み専用(ファイルが存在する場合はエラー)                           |
    | x+     | 読み書き両用(ファイルが存在する場合はエラー)                           |
    | b      | バイナリモード                                                         |
    | t      | テキストモード                                                         |

- ファイルを読み書きする。
  - open関数が返すfileオブジェクトの型は、オープンモードによって変化する
  - バイナリモードであれば、io.BufferedReaderまたは、io.BufferedWriterを返す。
  - テキストモードであれば、io.TextOWrapperです。

    ```Python
    file.write(s)

    file: ファイルオブジェクト
    s: 任意の文字列

    print関数とはことなり、引数のsの末尾には自動で改行文字を補わないので必要に応じて改行文字(\n)を加えておきます。
    ```

- ファイルを閉じる(close)
  - ファイルのように、複数のコードから利用される可能性があるものは、使い終わった後はきちんと閉じなければなりません。さもないと、Pythonファイルが占有してしまい、他のコードからファイルを開けなくなってしまう可能性があるからです。
  - ただし、コードが複雑になってくると、closeのし忘れも増えてくる。また、そもそも複数のコードで利用するリソースは利用範囲を明確にし、できるだけ利用時間をなくすべきです。
  - Pythonは自動でクローズする仕組みとしてwith命令を提供している。

    ```Python
    with open(...) as var:
      ...statements...

    var: fileオブジェクトを格納する変数
    statements: ファイルを操作するコード
    ```

    ```Python
    with open('./chap07/access.log', 'a', encoding='UTF-8') as file:
      file.write(f"{dateitme.now()}\n")
    ```

- エラーモード
  - ファイル操作に際して、想定しない文字が含まれているなどで、データを正しく読み書きできない場合があります。
  - その時の対処方法を表すのがエラーモードの役割です。

    ```Python
    file = open('./chap07/access.log', 'w', encoding="UTF-8", errors="replace")
    ```

    | 規定値            | 概要                                               |
    | :---------------- | :------------------------------------------------- |
    | strict            | エンコーディングエラー時、ValueErrorを発生(既定)   |
    | ignore            | エラーを無視                                       |
    | replace           | 不正な形式のデータを「?」で置き換え                |
    | surrogateescape   | 不正なバイト列をU+DC80～U+DCFF(私用領域)で置き換え |
    | xmlcharrefreplace | 不正な文字を「&#nnn:」で置き換え(書き込み時のみ)   |
    | backslashreplace  | 不正な文字をエスケープシーケンスで置き換え         |
    | namereplace       | 不正な文字を「\N{...}」で置き換え(書き込み時のみ)  |

#### 📒 7.2.2 テキストフィルの読み込み

- あらかじめテキストファイルを読み込んで、その内容を出力する例。

  ```Python
  with open("./chap07/sample.txt", "r", encoding="UTF-8") as file:
      data = file.read()
  print(data)
  ```

  - readメソッド

    ```Python
    read(size=-1)

    size: 読み込む文字数(-1でファイルの内容をすべて取得)
    ```

- **行単位にファイルを取得する**
  - 行単位に文字列を分割してリストに返してくれるのがreadlinesメソッド。
- **fileオブジェクトをループする**
  - fileオブジェクトをそのままforループで渡すことで、ファイルの内容を行単位で読み込むこともできる。
- **シーク位置を変更する**
  - オープンモード既定のシーク位置をseek()メソッドを利用することで変更できる。

#### 📒 7.2.3 バイナリファイルの読み書き

- バイナリデータを読み書きするならば、open関数で、rb, wbのように、読み書きを表すオープンモードに「b」(バイナリモード)を追加するだけ。

#### 📒 7.2.4 タブ区切り形式のテキストを読み書きする

- csvモジュールを利用することで、タブ／カンマ区切りなど、区切り文字付きテキストを手軽に読み書きできるようになる。
- 区切りファイルを読み込むには、まず、reader関数でreaderオブジェクトを生成する。

  ```Python
  reader(csvfile, **fmtparams)

  csvfile: 読み込み対象ファイル
  fmtparams: フォーマット情報(「名前 = 値」形式。指定できる名前は表7.9)
  ```

- reader関数のフォーマット情報

  | パラメータ       | 概要                                 | 既定値            |
  | :--------------- | :----------------------------------- | :---------------- |
  | delimiter        | 区切り文字                           | ,(カンマ)         |
  | doublequote      | 文字列内のクォート文字を二重化するか | True              |
  | escapechar       | エスケープに利用する文字             | None              |
  | lineterminator   | 改行文字(readerでは無視)             | \r\n              |
  | quotechar        | クォート文字                         | "                 |
  | quoting          | クォートの認識方法                   | csv.QUOTE_MINIMAL |
  | skipinitialsapce | delimiterの直後の空白を無視するか    | False             |
  | strict           | 不正な入力でエラーを発生させるか     | False             |

- **タブ区切りテキストを出力する**
  - csv.write関数を利用することで、リストの内容をカンマ／タブ区切り形式のテキストに変換することも可能
  - writer関数

    ```Python
    writer(csvfile, dialect='excel', **fmtparams)

    csvfile: 読み込み対処のファイル
    dialect: 採用するdialiect
    fmtparams: フォーマット情報(「名前 = 値」形式。指定できる名前)
    ```

    | 設定値               | 概要                                                   |
    | :------------------- | :----------------------------------------------------- |
    | csv.QUOTE_ALL        | すべてのフィールドをクォート                           |
    | csv.QUOTE_NOTNULL    | Noneでないすべてのフィールドをクォート                 |
    | csv.QUOTE_MINIMAL    | delimiter／quotecharなどを含むフィールドだけをクォート |
    | csv.QUOTE_NONNUMERIC | 非数値フィールドをクォート                             |
    | csv.QUOTE_STRINGS    | 文字列フィールドをクォート(ただし、Noneはクォートなし) |
    | csv.QUOTE_NONE       | クォートなし                                           |

  - writerowsメソッド

    ```Python
    writer.writerows(rows)

    writer: writeオブジェクト
    rows: 書き込むべきデータ(2次元リストなど)
    ```

#### 📒 7.2.5 オブジェクトのシリアライズ

- **シリアライズ**(Serialize)とは、オブジェクトのような構造化データをバイト配列に変換することをいう。
- シリアライズによって、オブジェクトを例えばファイル／データベースに保存したり、ネットワーク経由で受け渡したりが可能になる。
- シリアライズされたバイト配列を、元のオブジェクトに戻すことを**デシリアライズ**という。
- Pythonでは、シリアライズ／デシリアライズは**pickle**モジュールを利用する

- **オブジェクトのシリアライズ**

  ```Python
  import pickle

  from booke import Book

  b = Book("978-4-7981-5382-7", "独習C#新版", 3600)

  with open("./chap07/book.bin", "wb") as file:
      pickle.dump(b, file)
  ```

  - 上記、pickleではシリアライズ可能であることを**pickle化**と言う。
  - dump関数

    ```Python
    dump(obj, file, protocol=None)

    obj: シリアライズするお部ジェクト
    file: 出力先のファイル
    protocol: 利用するプロトコル(0～5)
    ```

  - protocolの値

    | プロトコル | 概要                                             |
    | :--------- | :----------------------------------------------- |
    | 0          | 人間に判読可能な形式                             |
    | 1          | 旧型式のバイナリ                                 |
    | 2          | より効率的な形式                                 |
    | 3          | bytesサポートの形式                              |
    | 4          | 巨大なオブジェクトのサポートなど効率化された形式 |
    | 5          | 帯域外データのサポート                           |

- シリアライズした内容をデシリアライズする。

  ```Python
  import pickle

  with open("./chap07/book.bin", "rb") as file:
      b = pickle.load(file)
      print(b.title)

  ```

  ```Python
  load(file)

  file:対象のファイル
  ```

### 📒 7.3 ファイルシステムの操作

- os.path/shutilなどのモジュールには、ファイルシステム上のフォルダー／ファイルを操作したり、情報を取得したりするための機能が用意されている。

#### 📒 7.3.1 フォルダー配下のファイル情報を取得する(1)

- osモジュールのlistdir関数を利用することで、指定したフォルダー配下のサブフォルダ／ファイル情報をリストとして取得できる。
- listdir関数：

  ```Python
  listdir(path='.')

  path: 列挙対象のフォルダー
  ```

#### 📒 7.3.2 フォルダー配下のファイル情報を取得する(2)

- フォルダー／ファイルの情報を纏めて取得するscandir関数
- scandir関数の戻り値

  | 属性／メソッド | 概要                             |
  | :------------- | :------------------------------- |
  | name           | ベースファイル名                 |
  | path           | パス                             |
  | id_dir()       | ディレクトリ(フォルダー)であるか |
  | is_file()      | ファイルであるか                 |
  | is_symlink()   | シンボリックリンクであるか       |
  | is_junction()  | ジャンクションであるか           |
  | stat()         | ファイルの属性                   |
  | st_mode        | ファイルモード                   |
  | st_size        | サイズ(byte単位)                 |
  | st_atime       | 最終アクセス時刻(秒単位)         |
  | st_mtime       | 最終更新時刻(秒単位)             |
  | st_birthtime   | 作成時刻(秒単位)                 |

#### 📒 7.3.3 フォルダー／ファイル情報を再帰的に取得する

- listdir/sacandir関数が指定されたフォルダー直下のサブフォルダ／ファイルの一覧を取得するのに対して、walk関数ｗを利用することで、サブフォルダーを再帰的に下って、フォルダー配下のすべてのサブフォルダー／ファイル情報を取得できる。
- walk関数

  ```Python
  walk(top, topdown=True)

  top: 走査するフォルダーのパス
  topdown: 上位フォルダーから走査するか(Falseで下位フォルダーから走査)
  ```

#### 📒 7.3.4 フォルダーを作成／リネーム／削除する

- osモジュールの関数を利用することで、フォルダーを新規作成、リネーム、削除できる。
- フォルダー操作のための関数

  | 関数                   | 概要                                           |
  | :--------------------- | :--------------------------------------------- |
  | mkdir(path, mode=0o777 | フォルダーpathを新規作成(modeはパーミッション) |
  | rename(src, dst)       | フォルダーsrcをdstにリネーム                   |
  | rmdir(path)            | フォルダーpathを削除する                       |

#### 📒 7.3.5 フォルダーを作成／リネーム／削除する(複数階層)

- mkdir／rename／rmdir関数には複数の階層に対応した関数が用意されている。

  | 関数                      | 概要                                           |
  | :------------------------ | :--------------------------------------------- |
  | makedirs(path, mode=0o777 | フォルダーpathを新規作成(modeはパーミッション) |
  | renames(src, dst)         | フォルダーsrcをdstにリネーム                   |
  | removermdirs(path)        | フォルダーpathを削除する                       |

#### 📒 7.3.6 フォルダー／ファイルをコピーする

- shutilモジュールのcopytree関数を利用することで、指定されたフォルダー配下のすべてサブフォルダー／ファイルを纏めて複製できる

  ```Python
  copytree(src, dst, ignore=None, copy_function=copy2)

  src: コピー元のフォルダー
  dst: コピー先のフォルダー
  ignore: コピーをスキップするフォルダー／ファイル
  copy_function: コピーに利用する関数
  ```

  ```Python
  import shutil

  shutil.copytree(
      "./chap07/doc", "./chap07/data", ignore=shutil.ignore_patterns("*.dat", "*.log")
  )
  ```

  - 引数ignoreにはコピーしないフォルダー／ファイルパターンを渡す。
    - ファイルパターンは、shutil.ignore_patterns関数で生成する。
  - 引数copy_functionはファイルのコピーに内部的に利用する関数を表す

    | 関数     | 概要                                     |
    | :------- | :--------------------------------------- |
    | copyfile | データのみコピー                         |
    | copy     | データ+パーミッションをコピー            |
    | copy2    | データ+パーミッション+メタデータをコピー |

  - copy2関数

    ```Python
    copy2(src, dst, *, follow_symlinks=True)

    src: コピー元のファイル
    dst: コピー先のファイル
    follow_symlinks: シンボリックリンクを追跡するか
    ```

### 📒 7.4 HTTP経由でコンテンツを取得する

- 近年、ネットワーク経由で情報／サービスにアクセスする状況が増えている。例えば、スクレピングはサイト上のページから情報を抽出する技術のことで、インターネット上から情報を効率的に収集するために用いられる。
- これらの技術を支えるモジュールがrequestsモジュールです。
- HTTP経由で外部の情報／サービスにアクセスするための手段を提供する
- requestsライブラリのインストール
  - pip install requests
  - pip freeze > requirements.txt

#### 📒 7.4.1 requestsモジュールの基本

- requestsモジュールの基本的なサンプルから見ていく。Codezine(https://codezine.jp/)にアクセスして取得したページをコンソールにテキスト表示する例です。

  ```Python
  import requests

  res = requests.request("get", "https://codezine.jp/")
  print(res.text)
  ```

  - request関数

    ```Python
    request(method, url, **kwargs)

    method: HTTPメソッド
    url: URL
    kwargs:　「オプション名：値」形式のオプション
    ```

    | オプション      | 概要                                          |
    | :-------------- | :-------------------------------------------- |
    | params          | クエリ情報「キー名：値」形式の辞書            |
    | data            | リクエスト本文「キー名：値」形式の辞書        |
    | json            | リクエスト本文                                |
    | headers         | リクエストヘッダー「ヘッダー名:値」形式の辞書 |
    | cookies         | クッキー「クッキー名:値」形式の辞書           |
    | files           | ファイル「名前:値」形式の辞書                 |
    | timeout         | タイムアウト時間                              |
    | allow_redirects | リダイレクトを追跡するか                      |

  - request関数の戻り値は、サーバからの応答データを表すResponseオブジェクトです。
    - Responseオブジェクトの主な属性／メソッド

    | 属性／メソッド               | 概要                         |
    | :--------------------------- | :--------------------------- |
    | apparent_encoding            | 見た目の文字エンコーディング |
    | content                      | コンテンツ本体(バイト単位)   |
    | headers                      | 応答ヘッダ(辞書)             |
    | iter_lines(chunk_size=10240) | 応答データ反復処理           |
    | json()                       | JSONデータを取得             |
    | raw                          | 生のデータ                   |
    | status_code                  | 応答ステータスコード         |
    | reason                       | 応答ステータス(テキスト)     |
    | text                         | コンテンツ本体(Unicode)      |
    | url                          | 最終的なURL                  |

#### 📒 7.4.2 HTTP POSTによる通信

- まとまったデータを送信するには、HTTP POSTを利用する

  ```Python
  import requests

  res = requests.post("https://wings.msn.to/tmp/post.php", data={"name": "佐々木新之助"})
  print(res.text)

  ```

#### 📒 7.4.3 JSONデータを取得する

- HTTP 経由でデータの受け渡しする場合、JSON(JavaScript Object Notation)と呼ばれる形式がよく利用される。
- JSONとは名前の通り、JavaScriptのオブジェクトリテラルをもとにしたデータ形式でその性質上、JavaScriptとの親和性に優れる。

  ```Python
  import requests

  res = requests.get("https://wings.msn.to/tmp/books.json")
  bs = res.json()
  print(bs["books"][0]["title"])
  ```

### 📒 7.5 その他の機能

#### 📒 7.5.1 数学演算 -- math モジュール + 組み込み関数

- 絶対値や平方根、三角関数など、基本的な数学演算は、mathモジュールと組み込み関数とで提供されている。

#### 📒 7.5.2 乱数を生成する - randomモジュール

- 乱数を生成するには、randomモジュールを利用する。randomモジュールでは、用途に応じて、乱数生成関数が用意されている

#### 📒 7.5.3 データ型を変換／判定する - int - float関数など

- データ型変換のための組み込み関数

| 関数               | データ型     |
| :----------------- | :----------- |
| bool([x])          | 論理型       |
| complex([x])       | 複素数型     |
| int([x,[base=10]]) | 整数型       |
| float([x])         | 浮動小数点型 |
| str(object='')     | 文字列型     |

#### 📒 7.5.4 モジュール／クラスに含まれる要素を確認する

- 組み込み関数dirを利用することで、指定されたモジュール／クラスに属する要素を確認することができる

### 📒 8. ユーザー定義関数

- アプリ開発者が自らがクラス／関数を定義することもできる。このようなクラス／関数を、**ユーザー定義クラス**、**ユーザー定義関数**という。

#### 📒 8.1 ユーザー定義関数の基本

- ユーザー定義関数とは、まさに重複したコードを一か所にまとめるための仕組み

#### 📒 8.1.1 ユーザー定義関数の基本構文

- 以下は、ユーザー定義関数の基本的な構文です。ユーザー定義関数は、def命令で定義できる。

```Python
def 関数名(引数,....):
  ...任意の処理...
  return 戻り値
```

#### 📒 8.1.2 関数名

- 識別子の命令規則に従うのは、変数の場合と同じです。get_triangle,update_infoのようなアンダースコア形式で表す。
- 関数としての役割を把握できるような命令を意識すること
  - add_elementのように「動詞 + 名刺」の形式で命名することをお勧め。

#### 📒 8.1.3 仮引数と実引数

- **引数**とは、関数の中で参照可能な変数のことです。
  - 呼び出し元から渡される値のこと**実引数**
  - 受け取り側の変数のこと**仮引数**
- **(1) 引数の個数**
  - 引数の個数の上限は255個で、現実的な用途では無制限と考える
- **(2) 引数の名前**
  - 名前の一貫性にも意識するべきです。
- **(3) 引数の並び順**
  - 「重要なものから」、「関連する情報を隣接するように」並べるべきです。

#### 📒 8.1.4 戻り値

- 引数(仮引数)が関数の入り口であるとするならば、**戻り値(返り値)**は、関数の出口-関数が処理した結果を表す。
  ```Python
  return 戻り値
  ```

### 📒 8.2 型アノテーション

- **型アノテーション**を利用することで、関数に不正な型が渡されることを未然に防げるようになる

#### 📒 8.2.1 型アノテーションの基本

- 引数の型は仮引数の直後に「:型名」形式で指定する。
- 戻り値の型は引数リストの直後に「->型名」の形式で、それぞれ表す

  ```Python
  def get_triangle(base: float, height: float) -> float:
      return base * height / 2
  ```

- **変数宣言にも利用できる**

  ```Python
  msg:str = "こんにちは、世界！"
  ```

#### 📒 8.2.2 さまざまな型アノテーション

- **Any型**
  - いわゆる「何でも」型です。どのような型としてもふるまえるので、以下は正しいコードです。

    ```Python
    from typing import Any

    data: Any = 1  # 数値でも...
    data = "one"  # 文字列でも....
    data.hoge()  # 　任意のメソッド呼び出しも許容
    ```

- **許容型(Union型)**
  - 共用型とは、いわゆる「複数の型の中のどれか」を表す型。型を(|)で区切ることで表現する。

- **None許容型**
  - 一般的な型は、None代入を許容しない。
    ```Python
    data: int = none
    ```
  - 以下のように共用型を定義することでNone代入を許容する。
    ```Python
    data: int | None = None
    data = 100
    ```

- **ジェネリック型**
  - リストのような複合型でただリストであることは、さほど意味がない

    ```Python
    data:list = [1, True, 'Hoge', None]
    ```

  - 一般的にはリストの要素がstr、intなど特定の型であることを確認したいはずです。

    ```Python
    data:list[str] = [1, True, 'Hoge', None]
    ```

- **リテラル型**
  - リテラル型とは名前の通り、リテラル(特定の値)をそのまま型として利用できる仕組み

    ```Python
    from datetime import datetime
    from typing import Literal


    def now(type: Literal["datetime", "date", "time"]) -> str:
        dic = {"datetime": "%c", "date": "%x", "time": "%X"}
        dt = datetime.now()
        return dt.strftime(dic[type])


    print(now("datetime"))
    # print(now("dat")) # 型違反警告
    ```

- **文字リテラル型**
  - 任意の文字列、リテラルであることを制限する型が文字リテラル型です。

  ```Python
  from typing import LiteralString


  def build_sql(keyword: LiteralString) -> str:
      return f'SELECT * FROM items WHERE keyword = "{keyword}"'


  print(build_sql("Python"))

  # key = input()
  # print(build_sql(key)) # 型 "str" の引数を、関数 "build_sql" の型 "LiteralString" のパラメーター "keyword" に割り当てることはできません。
  ```

- **定数型**
  - Final型を用いることで定数を表現することが可能

    ```Python
    from typing import Final

    PI: Final[float] = 3.14159
    # PI = 3.1415926535 # "PI" は Final として宣言されており、再割り当てできません

    ```

- **型エイリアス**
  - type命令で指定の型に別名(エイリアス)を付与しなさい、という意味になる

    ```Python
    type alias = anno

    alias: 型の別名
    anno: 型アノテーション
    ```

    ```Python
    from datetime import datetime
    from typing import Literal

    type UserInfo = tuple[str, Literal["male", "female"], datetime, bool]
    p: UserInfo = ("Yamada, Yoshihiro", "male", datetime(2007, 6, 25), True)
    ```

### 📒 8.3 変数の有効範囲(スコープ)

- **スコープ**とは、コードの中でも変数の有効範囲のこと、変数がコードのどこから参照できるかを決める概念です。
- Pythonのスコープは以下に分類できる
  - コード全体から参照できる**グローバルスコープ**
  - 定義された関数の中でのみ参照できる**ローカルスコープ**

#### 📒 8.3.1 グローバル変数とローカル変数

- グローバルスコープを持つ変数のことを**グローバル変数**、ローカルスコープを持つ変数のことｗお**ローカル変数**という。
- **スコープをまたいで参照する場合**
  - スコープをまたいだ例

    ```Python
    data1 = "グローバル"


    def check_scope():
        data2 = "ローカル"
        return data1


    print(check_scope())
    # print(data2)  # NameError: name 'data2' is not defined
    ```

  - **スコープ間で識別子が衝突した場合**

    ```Python
    data = "グローバル"


    def check_scope():
        data = "ローカル"
        return data


    print(check_scope())
    print(data)
    ```

  - **より厳密な変数の有効範囲**
    - ローカル変数は関数の先頭で宣言する
  - **関数を入れ子に定義した場合**
    - ユーザー定義関数は、入れ子に定義することもできる

      ```Python
      data = "global"


      def outer() -> str:
          data = "outer"

          def inner() -> str:
              data = "inner"
              return data

          return inner()


      print(outer())

      ```

#### 📒 8.3.2 関数内でグローバル変数を利用する - global/nonlocal

- 関数内からグローバル変数を操作した場合、**global**命令を利用することで、関数内の変数を強制的にグローバルスコープに割り当てることができる。
- **内側の関数から外側の関数のローカル変数を利用する - nonlocal命令**

  ```Python
  data = "global"


  def outer() -> None:
      data = "outer"

      def inner() -> str:
          # global data
          nonlocal data
          data = "inner"
          return data

      print(inner())
      print(data)


  outer()
  print(data)
  ```

#### 📒 8.3.3 ブロックレベルのスコープ

- Pythonではブロックレベルのスコープが存在しないため、以下のifを抜けた場合も変数iは存在し続ける。

### 📒 8.4 引数のさまざまな記法

- ユーザー定義関数の基本を理解できたところで、以降はユーザー定義関数に関係するさまざまなテクニックを紹介する。

#### 📒 8.4.1 引数の既定値

- 「引数=値」の形式で、仮引数に既定値を設定できる。
- 既定値を利用する場合の注意点
  - 関数の既定値は、定義時点で一度だけ評価されるの基本です。この性質上、以下ようのなケースでは要注意です。
  - (1) 既定値として変数を受け取る場合
    - my_func関数の引数paramが既定値として変数msgを受け取る例

      ```Python
      msg = "before"


      def my_func(param: str = msg) -> None:
          print(param)


      msg = "after"
      my_func()

      ```

    - 既定値を評価するのは定義のタイミングのため、msgは「before」となる。

  - (2) 既定値がミュータブルなオブジェクトの場合

    ```Python
    def my_func(value: int, data: list[int] | None = None) -> list[int]:
        if data is None:
            data = []
        data.append(value)
        return data


    print(my_func(13))
    print(my_func(108))
    ```

#### 📒 8.4.2 キーワード引数

- **キーワード引数**とは、呼び出し時には名前を伴う引数のこと。キーワード引数を利用することで以下のような呼び出し可能になる。

  ```Python
  def get_triangle(base: float = 5, height: float = 1) -> float:
      return base * height / 2


  print(get_triangle(height=10))
  print(get_triangle(height=10, base=2))

  ```

- キーワード引数を利用することで、以下のようなメリットがある。
  - 引数が多くても、意味を把握しやすい
  - 必要な引数だけスマートに表現できる
  - 引数の順序を自由に変更できる。
- 呼び出しに際して、明示的に名前を指定しなければならないので、コードが冗長になるデメリットもある
  - そもそも引数の数が多い
  - 省略可能な引数が多く、省略パターンにもさまざまな組み合わせがある
  - 上記のようなケースでは有効

- **キーワード引数／位置引数を強制する**
  - 仮引数リストの途中に「\*」を加えることで、それ以降の引数はキーワード引数として渡せなければならないという指定になる。

    ```Python
    # arg2,3はキーワードは引数であること
    def my_func(arg1: int, *, arg2: int = 0, arg3: int = 0) -> None:
        pass


    # my_func(1, 2, 3)  # エラー　1 個の位置引数が必要です
    my_func(1, arg2=2, arg3=3)  # OK

    ```

  - Python3.8以降では引数のリストの途中に「/」を加えることで、それ以前の引数は位置引数であることを強制できるようになる

    ```Python
    # arg1は位置引数であること
    def my_func(arg1: int, /, arg2: int = 0, arg3: int = 0) -> None:
        pass


    # my_func(arg1=10, arg2=20)  # エラー さらに 1 つの位置引数が必要です
    my_func(10, arg2=20)  # OK

    ```

#### 📒 8.4.3 可変長引数の関数

- **可変長引数**の関数とは、引数の個数が予め決まっていない関数です。

  ```Python
  def total_products(*values: int) -> int:
      result = 1
      for value in values:
          result *= value
      return result


  print(total_products(12, 15, -1))
  print(total_products(5, 7, 8, 2, 1, 15))
  ```

- **可変長引数の注意点**
  - (1) 可変長引数は1関数1つまで
  - (2) 可変長引数の後方にはキーワード引数のみ指定できる
  - (3) 想定される引数まで可変長引数に纏めない。
  - (4) 可変長引数で「1個以上の引数」を表す方法

#### 📒 8.4.4 可変長引数(キーワード引数)

- 「\*」の代わり「\*\*」を付与することで、不特定のキーワード引数を受け取ることができる。

  ```Python
  def create_dict(**kwargs: str | int) -> dict[str, str | int]:
      result = dict()
      for key, value in kwargs.items():
          result[key] = value
      return result


  d = create_dict(name="山田太郎", age=30, sex="male")
  print(d)

  ```

- **TypedDictによる \*\*kwargsの型定義**
  - Python3.12以降では、typedDictを使って、個々のキーワード単位に型を指定できるようになった。

    ```Python
    from typing import NotRequired, TypedDict, Unpack


    # title, size, fullキーを持つ型付き辞書を準備
    class KeywordArgs(TypedDict):
        title: str
        size: int
        full: NotRequired[bool]


    def hoge(**kwargs: Unpack[KeywordArgs]) -> None:
        print(kwargs)


    hoge(title="Python入門", size=100, full=True)
    hoge(title="Hello", size=100)
    # hoge(title="Hello", full=True) # エラー
    # hoge(title="Hello", size="100px") # エラー
    # hoge(title="Hello", size=100, none='none') # エラー

    ```

#### 📒 8.4.5 「\*」「\*\*」による引数の展開

- 関数の定義時ではなく、呼び出しのときも「\*」は利用できる。実引数での「\*」はリスト／タプルの値をここの値に分解しなさいという意味になる。

  ```Python
  data = ["こんにちは", "おはよう", "おやすみ"]
  print(data)
  print(*data)

  ```

- 同様に「\*\*」を付与することで、辞書(dict)をキーワード引数に展開できます。

```Python
data = ["こんにちは", "おはよう", "おやすみ"]
keywd = {"sep": ",", "end": "●"}
print(*data, **keywd)  # type: ignore

```

### 📒 8.5 関数呼び出しと戻り値

#### 📒 8.5.1 複数の戻り値

- 関数から複数の値を返したいというケースはよくある。この場合、戻り値をタプルとして束ねて返すのが一般的です。
- 与えられた任意の引数に対して、それぞれ、最大値／最小値を求めるget_max_min関数の例

  ```Python
  def get_max_min(*args: float) -> tuple[float, float]:
      return (max(args), min(args))


  max_v, min_v = get_max_min(15, 7.5, 108, -10)
  print(max_v)
  print(min_v)

  ```

- **名前付きのタプルを生成する**
  - typingモジュールNamedTuple関数を利用する

    ```Python
    from typing import NamedTuple

    # MaxMin型の名前付きタプルを定義
    MaxMin = NamedTuple("MaxMin", [("max", float), ("min", float)])


    def get_max_min(*args: float) -> MaxMin:
        return MaxMin(max(args), min(args))


    result = get_max_min(15, 7.5, 108, -10)
    print(result.max)
    print(result.min)
    print(result[0])

    ```

  - NamedTuple関数

    ```Python
    NamedTuple(typename, field_names)

    typename: 型の名前
    field_names: 「要素名, 型」形式(タプル)のリスト
    ```

#### 📒 8.5.2 再帰関数

- **再帰関数**とは、自分自身の呼び出している関数のこと。
- 例えば階乗を求めるfactorial関数の例

  ```Python
  def factorial(num: int) -> int:
      if num != 0:
          return num * factorial(num - 1)
      return 1


  print(factorial(5))

  ```

#### 📒 8.5.3 高階関数

- 「関数を引数／戻り値として扱う関数」のことを高階関数という。
- **高階関数の基本**

  ```Python
  from collections.abc import Callable
  from typing import Any


  # 高階関数walk_list関数を定義
  def walk_list(data: list[Any], func: Callable[[Any, int], None]) -> None:
      # リストの内容を順に処理
      for key, value in enumerate(data):
          # func経由で指定の関数を呼び出し
          func(value, key)


  # リストを処理するためのユーザー定義関数
  def show_item(value: Any, key: int) -> None:
      print(key, ":", value)


  data = [105, 53, 27, 87, 33]
  walk_list(data, show_item)

  ```

#### 📒 8.5.4 無名関数(ラムダ式)

- \*\*ラムダ式(lambda式)構文：名前の通り、関数を式として表現できる。そのまま引数に渡せる。
- ラムダ式

  ```Python
  lambda 引数, ....: 戻り値となる式
  ```

  ```Python
  from collections.abc import Callable
  from typing import Any


  # 高階関数
  def walk_list(data: list[Any], func: Callable[[Any, int], None]) -> None:
      for key, value in enumerate(data):
          func(value, key)


  data = [105, 53, 27, 87, 33]
  walk_list(data, lambda value, key: print(key, ":", value))
  ```

- **ラムダ式のさまざまな書き方**
  - (1) 変数に代入する
    ```Python
    calcu = lambda num: num * 2
    print(calcu(10)) # 結果 20
    ```
  - (2) 引数を持たないラムダ式
    ```Python
    from datetime import date
    now = lambda: date.today()
    print(now())
    ```
  - (3) 条件分岐を伴うラムダ式
    ```Python
    isPass = lambda point: '合格' if point > 70 else '不合格'
    ```

#### 📒 8.5.5 関数のオーバーロード

- **オーバーロード**とは、「名前は同じで、引数が異なる関数を複数設置」するための仕組み

  ```Python
  def process(value: int | str) -> int | str:
      if isinstance(value, int):
          return str(value)
      elif isinstance(value, str):
          return len(value)
      else:
          raise TypeError("不正な型です。")


  result1: str = process(123)  # type: ignore
  result2: int = process("hoge")  # type: ignore

  ```

- isinstance 関数

```Python
isinstance(obj, clazz)

obj: 判定するインスタンスの値
clazz: 任意の型
```

#### 📒 8.5.6 型ガード

- **型ガード**とは変数の型を特定することで、対象となった変数の型を絞り込むための仕組みです。

  ```Python
  def process(value: str | int) -> str | int:
      if isinstance(value, str):
          return value.upper()
      else:
          return value + 10


  print(process("abc"))
  print(process(100))

  ```

- **ユーザー定義の型ガード関数**

  ```Python
  from typing import Any, TypeIs


  class Magazine:
      pass


  class Book:
      def __init__(self, title: str) -> None:
          self.title = title

      def show_title(self) -> str:
          return self.title[:10]


  # def process(data: Book | Magazine) -> str | None:
  #     if hasattr(data, "title"):
  #         return data.show_title()


  def is_book(data: Any) -> TypeIs[Book]:
      return hasattr(data, "title")


  def process(data: Book | Magazine) -> str | None:
      if is_book(data):
          return data.show_title()


  if __name__ == "__main__":
      print(process(Book("これからはじめるReact実践入門")))

  ```

## 📒 9. ユーザー定義関数(応用)

### 📒 9.1 デコレーター

- **デコレーター(関数デコレーター)**は、既存の関数に機能を追加する仕組みです。

#### 📒 9.1.1 デコレーターを利用しない例

```Python
from collections.abc import Callable
from typing import Any


def log_func(func: Callable[..., Any]) -> Callable[..., Any]:
    # 関数内関数を定義
    def inner(*args, **keywds):
        print("----------")
        print(f"Name: {func.__name__}")
        print(f"Args: {args}")
        print(f"Keywds: {keywds}")
        print("----------")
        return func(*args, **keywds)

    return inner


def hoge(x: int, y: int, m: str = "bar", n: str = "piyo") -> None:
    print(f"hoge: {x}-{y}/{m}-{n}")


# log_func関数の戻り値を実行
log_hoge = log_func(hoge)
log_hoge(10, 37, m="ほげ", n="ぴょ")
```

#### 📒 9.1.2 デコレータ―の基本

```Python
from collections.abc import Callable
from typing import Any


def log_func(func: Callable[..., Any]) -> Callable[..., Any]:
    # 関数内関数を定義
    def inner(*args, **keywds):
        print("----------")
        print(f"Name: {func.__name__}")
        print(f"Args: {args}")
        print(f"Keywds: {keywds}")
        print("----------")
        return func(*args, **keywds)

    return inner


@log_func
def hoge(x: int, y: int, m: str = "bar", n: str = "piyo") -> None:
    print(f"hoge: {x}-{y}/{m}-{n}")


hoge(15, 37, m="ほげ", n="ぴょ")

```

- 拡張したい関数(ここではhoge)の頭に「@名前」の形式で、高階関数を指定するだけです。
- これでhoge関数はlog_func関数で拡張された(=修飾された)とみなされる。

#### 📒 9.1.3 標準デコレーターの例

- **関数／メソッドなどが非推奨であることを宣言する - @deprecated**
  - warningsモジュールのdeprecatedデコレータを利用することで、関数／メソッドが非推奨であることを利用者に警告する。
- **関数の結果をキャッシュする - @lru_cache**
  - もうひとつ、functoolsモジュールの@lru_cacheデコレーターを使って、関数の結果をキャッシュする。

#### 📒 9.1.4 引数を受け取るデコレーター

- 引数を受け取るデコレーターでは関数の入れ子が1段階増える点に注目です。外側から、
  - デコレーターの引数を受け取る(log_func)
  - 修飾すべき関数を受け取る(outer)
  - 修飾すべき関数の引数を受け取る(inner)

    ```Python
    from collections.abc import Callable
    from typing import Any


    # デコレーターの引数を受け取る
    def log_func(
        details: bool = True,
    ) -> Callable[[Callable[..., Any]], Callable[..., Any]]:

        # 修飾すべき関数を受け取る
        def outer(func: Callable[..., Any]) -> Callable[..., Any]:
            # 本来の関数に渡すべき引数を受け取る
            def inner(*args, **keywds):
                print("----------")
                print(f"Name: {func.__name__}")
                if details:
                    print(f"Args: {args}")
                    print(f"Keywds: {keywds}")
                print("----------")
                return func(*args, **keywds)

            return inner

        return outer


    @log_func(details=False)
    def hoge(x: int, y: int, m: str = "bar", n: str = "piyo") -> None:
        print(f"hoge: {x}-{y}/{m}-{n}")


    hoge(15, 37, m="ほげ", n="ぴょ")

    ```

#### 📒 9.1.5 クロージャー(関数閉方)

- 上位のローカル変数を参照した入れ子の関数のことを**クロージャー(関数閉方)**と呼びます。
- **スコープチェーンによる理解**
  - 入れ子のinner関数(入れ子のローカルスコープ)
  - トップレベルのlog_func関数(ローカルスコープ)
  - グローバルスコープ

    ```Python
    from collections.abc import Callable


    def counter(init: int) -> Callable[[], int]:
        # カウント値
        count = init

        # カウント値をインクリメントする内部関数
        def increment() -> int:
            nonlocal count
            count += 1
            return count

        return increment


    c1 = counter(1)
    c2 = counter(25)

    print(c1())
    print(c1())
    print(c2())
    print(c2())

    ```

### 📒 9.2 ジュネレーター

- **ジュネレーター**の見た目は、普通の関数です。
- ジュネレーターはyieldという命令を利用することで、その時どきの値を返せる点が異なる。

#### 📒 9.2.1 yield命令

- yieldはreturnとよくにた命令で関数の値を呼び出し元に返す。
  - return文 ➡ その場で関数を終了する
  - yield文 ➡ 処理を一時停止します。

  ```Python
  from collections.abc import Generator


  def my_gen() -> Generator[str]:
      yield "あいうえお"
      yield "かきくけこ"
      yield "さしすせそ"


  for value in my_gen():
      print(value)

  ```

- **ジェネレーター関数の戻り値**
  - ジェネレーター関数の戻り値は、Generatorオブジェクト
  - for ループは、Generatorオブジェクトを取得して、さらにそこから個々のyield値を取得するまで担っている。

#### 📒 9.2.2 素数を求めるジェネレーター

```Python
import math
from collections.abc import Generator


# 素数を求めるジェネレーター
def get_primes() -> Generator[int]:
    num = 2
    while True:
        if is_prime(num):
            yield num
        num += 1


# 引数valueが素数であるかを判定する
def is_prime(value: int) -> bool:
    result = True
    # 2 ～ sqrt(value)でvalue替わり消えれ宇(余りが0)ものがあるか
    for i in range(2, math.floor(math.sqrt(value)) + 1):
        if value % i == 0:
            result = False
            break
    return result


# 素数を順に出力する
for prime in get_primes():
    print(prime)
    # 素数が100を超えたところで、終了
    if prime > 100:
        break
```

#### 📒 9.2.3 ジュネレーターの主なメソッド

- **ジュネレーターを正常終了**
  - close
- **ジュネレーターに例外を投げる**
- **ジュネレーターに値を送出する**

  ```Python
  from collections.abc import Generator


  def gen_com() -> Generator[str, str]:
      while True:
          # ユーザー入力を要求
          n = yield input("名前を教えてください：")
          # sendメソッドからの値でメッセージを生成
          yield f"こんにちは、{n}さん！"


  gen = gen_com()
  for name in gen:
      # ジュネレーターからの戻り値(入力値)を再送出
      res = gen.send(name.upper())
      # ジュネレーターから戻り値(あいさつメッセージ)を表示
      print(res)

  ```

#### 📒 9.2.4 一部の処理を他のジェネレーターに委譲する

- yield from 命令を利用することで、ジェネレーターの中で別のジェネレーター(サブジェネレーター)を呼び出しこれを列挙できる
- yield from 命令

  ```Python
  yield from generator

  generator: 他のジェネレーター
  ```

  ```Python
  from collections.abc import Generator


  # リストから順にファイルパスを取り出して、読み込みはサブジェネレーターに委譲
  def read_files(*files: str) -> Generator[str]:
      for file in files:
          yield from read_lines(file)


  # ファイル読み込みを担うサブジェネレーター
  def read_lines(path: str) -> Generator[str]:
      with open(path, "r", encoding="UTF-8") as file:
          # 行単位にテキストを取得
          for line in file:
              yield line.rstrip("\n")


  # sample1 ～ 3.datの内容を順に列挙
  for line in read_files(
      "./chap09/sample1.dat", "./chap09/sample2.dat", "./chap09/sample3.dat"
  ):
      print(line)
  ```

#### 📒 9.2.5 ジェネレーター式

- **ジェネレータ式**とは、ジェネレーターを簡易に定義するための構文のこと

  ```Python
  (式 for 仮変数 in シーケンス型)
  ```

  ```Python
  import random

  gen = (random.random() for i in range(100))

  for num in gen:
      print(num)

  ```

### 📒 9.3 関数のモジュール化

- ユーザー定義関数は一般的には別のファイルとして切り出して、それぞれのファイルからは必要に応じて取り込んで利用することが普通です。このような仕組みを提供するのが**モジュール**です。

#### 📒 9.3.1 モジュールの定義

- コードをモジュール化するために特別なコードは不要。関数／クラスをまとめたコードをそのまま.pyで保存するだけ。

#### 📒 9.3.2 モジュールをインポートする

- モジュール化されたコードを実行するには、import(from ... import)命令を利用する
- **モジュールに別名を付与する**
  - import .. as 命令を利用することで、モジュールに別名を付与することができる。

    ```Python
    import module as alias

    module: モジュール名
    alias: 別名
    ```

- **すべてのメンバーをインポートする**
  - from ... import 命令で「\*」を用いることで、すべてのメンバーをインポートすることができる
  - from ... import 命令(第２構文)

    ```Python
    from module import *

    module: モジュール名
    ```

- **「import \*」でのインポートを制限する**
  - 「from ... import \*」でインポートすべきメンバーを、モジュール側で制限することができる
    - (1) **all**変数で定義する

      ```Python
      __all__ = ["hoge", "foo", "bar"]


      def hoge() -> None:
          print("hoge")


      def foo() -> None:
          print("foo")


      def bar() -> None:
          print("bar")


      def piyo() -> None:
          print("piyo")

      ```

    - (2) 「\_名前」で命名する

      ```Python
      def hoge() -> None:
          print("hoge")


      def foo() -> None:
          print("foo")


      def bar() -> None:
          print("bar")


      def _piyo() -> None:
          print("piyo")

      ```

#### 📒 9.3.3 モジュールの検索先

- カレントフォルダー(現在のスクリプトが配置されているフォルダー)
- 環境変数PYTHONPATH (フォルダー名のリスト)
- 環境に応じた限定のパス

- **モジュールの検索パスを確認／追加する**
  - モジュールの検索先フォルダーは、sys.pathで取得できる
- **モジュール検索パスを恒久的に設定する**
  - (1) 環境変数PYTHONPATH
    - **環境変数**とはコンピュータごとに設定できる変数のこと
  - (2) .pth ファイル
    - パス設定ファイル(.pth)をsite-packageフォルダー配下に配置する。

#### 📒 9.3.4 インポート時の作法

インポートに際しては、以下のルールに沿うことでコードを読みやすくする

- 1モジュール1インポート
  - 1つのimport命令で複数のモジュールをインポートしません。
- インポートの記述場所／順序
  - 標準ライブラリ
  - サードベンダーが提供するライブラリ
  - アプリ独自のモジュール
- 相対インポートよりも絶対インポート

#### 📒 9.3.5 パッケージ

- 複数のモジュールを束ねる仕組みが**パッケージ**
- パッケージの基本
  - モジュールの実体がファイルであったのと同じく、パッケージの実体はフォルダー(ディレクトリ)です。
  - **パッケージを初期化する「\_\_init\_\_.py」**
    - 1. パッケージであることを宣言
    - 2. パッケージをインポートしたときに実行すべてき初期化処理を定義
    - 初期化処理がいらないのであれば、**init**.pyは空で問題ない。また、Python3.3以降は**init**.pyがなくてもPythonはフォルダーをパッケージとみなすので、**init**.pyを省略することも可能
- **絶対インポートと相対インポート**
  - 絶対インポート： モジュール検索パスを起点にモジュールを検索する
  - 相対インポート： 「.」は現在のパッケージ(フォルダー)を意味する。(「..」で1つ上のパッケージ、「...」で2つ上のパッケージを表すことができる)
- **名前空間パッケージ**
  - Python3.3以降では、異なるフォルダーに分散したパッケージ(フォルダー)を1つのパッケージとして束ねることができる。これを**名前空間パッケージ**という。
    - c:/data/nspack/hoge.py
    - c:/Temp/nspack/foo.py

      ```Python
      import sys

      sys.path.append("c:/data")
      sys.path.append("c:/Temp")

      import nspack.foo
      import nspack.hoge

      ```

- **パッケージの実行**
  - パッケージ(フォルダー)に、**main**.pyを用意することで、pythonコマンドでパッケージを呼び出したときに実行すべきコードを用意しておけます。
  - パッケージはzipファイルでも構わない。

### 📒 9.4 非同期処理

- **同期処理**
  - ある処理が呼び出されたら、その処理が終了した後、次の処理が呼び出されるような処理のこと
- **非同期処理**
  - ある処理が呼び出された後、**完了を待たずに**次の処理を呼び出す。
  - asyncioモジュールと前提となる**コルーチン**という構文を学習する。

#### 📒 9.4.1　コルーチンの基本

- コルーチンとはサブルーチン(関数)によく似た仕組みですが、以下の点で異なる。
  - 関数：一度呼び出したら、最後まで実行
  - コルーチン：途中で中断でき、あとから再開も可能
- Pythonではコルーチンの性質を利用して、
  - 現在のコルーチンを処理する途中で待ちが発生したら中断
  - その間に他のコルーチンを実行し、終わったら元のコルーチンを再開
- **コルーチンの定義**

  ```Python
  async def コルーチン名(引数, ...):
    ... コルーチンの本体 ...
  ```

  - コルーチンはcoroutineオブジェクトを返却するだけです。そのまま関数の呼び出しでは、コルーチンは実行できない点に注目。
  - asyncio.run関数を利用する

    ```Python
    run(coro, *, debug = None)

    coro: 実行するコルーチン
    debug: デバックモードで実行するか(Trueで実行モードを有効化)
    ```

#### 📒 9.4.2 複数の非同期処理を実行する

- **タスクを利用した並列化**
  - **タスク(Task)**を利用する。Taskとはおおざっぱに言うと、コルーチンを並行に実行するためのオブジェクトです。
  - create_task関数にコルーチンを渡すことで、Taskを生成する

    ```Python
    import asyncio
    import time

    from coro import heavy


    async def main() -> None:
        t1 = asyncio.create_task(heavy("hoge", 2))
        t2 = asyncio.create_task(heavy("bar", 5))
        t3 = asyncio.create_task(heavy("piyo", 1))
        print(await t1)
        print(await t2)
        print(await t3)


    start = time.time()
    # コルーチンmainを実行
    asyncio.run(main())
    end = time.time()
    print(f"Process Time: {end - start}")

    ```

  - **gather関数を利用した例**
    - 無条件に非同期処理を並列化するならば、asyncio.gather関数を利用しても問題ない。

      ```Python
      import asyncio
      import time

      from coro import heavy


      async def main() -> None:
          print(await asyncio.gather(heavy("hoge", 2), heavy("bar", 5), heavy("piyo", 1)))


      start = time.time()
      # コルーチンmainを実行
      asyncio.run(main())
      end = time.time()
      print(f"Process Time: {end - start}")

      ```

  - **TaskGroupを利用した例**
    - Python3.11ではタスクグループ化するためのTaskGroupが追加された。

      ```Python
      import asyncio
      import time

      from coro import heavy


      async def main() -> None:
          async with asyncio.TaskGroup() as group:
              t1 = group.create_task(heavy("hoge", 2))
              t2 = group.create_task(heavy("bar", 5))
              t3 = group.create_task(heavy("piyo", 1))
          print([t1.result(), t2.result(), t3.result()])


      start = time.time()
      # コルーチンmainを実行
      asyncio.run(main())
      end = time.time()
      print(f"Process Time: {end - start}")

      ```

      ```Python
      async with TaskGroup() as group:
        ... statements ...

      group: TaskGroupオブジェクトを格納する変数
      statements: タスクを追加するためのコード
      ```

#### 📒 9.4.3 非awaitableな処理をawait式に渡す

- イベントループのrun_in_executorメソッドを利用することで、非awaitableな処理をコルーチンとして扱うことができる
  - run_in_executorメソッド

    ```Python
    run_in_executor(executor, func, *args)

    executor: 非同期呼び出しを管理するエクゼキュター
    func: 実行する処理
    args: 引数 func に渡す引数(群)
    ```

    ```Python
    import asyncio
    import time

    import requests


    # 指定のURLにリクエストし結果を取得
    async def get_content(url) -> str:
        print(f"start {url}")
        loop = asyncio.get_event_loop()
        res = await loop.run_in_executor(None, requests.get, url)
        print(f"end {url}")
        return res.text[:100]


    # 非同期処理のエントリーポイント
    async def main() -> tuple[str, ...]:
        return await asyncio.gather(
            get_content("https://codezine.jp"),
            get_content("https://wings.msn.to"),
            get_content("https://www.web-deli.com"),
        )


    start = time.time()
    result = asyncio.run(main())
    end = time.time()
    print(result)
    print(f"Process Time: {end - start}")

    ```

  - [AIOHTTP](https://docs.aiohttp.org/en/stable/)
    - HTTP通信であればネイティブに対応したHTTP通信ライブラリ「aiohttp」があるので、こちらを検討する
    - pip install aiohttp

    ```Python
    import asyncio
    import time

    from aiohttp import ClientSession


    # 指定したアドレスからコンテンツを取得する
    async def get_content(session: ClientSession, url: str) -> str:
        print(f"start {url}")
        async with session.get(url) as response:
            text = await response.text()
            print(f"end {url}")
            return text[:100]


    async def main() -> tuple[str, ...]:
        # 通信クライアントを生成
        async with ClientSession() as session:
            result = await asyncio.gather(
                get_content(session, "https://codezine.jp"),
                get_content(session, "https://wings.msn.to"),
                get_content(session, "https://www.web-deli.com"),
            )
            return result


    start = time.time()
    result = asyncio.run(main())
    end = time.time()
    print(result)
    print(f"Process Time: {end - start}")

    ```

### 📒 9.5 ドキュメンテーション

- ユーザー定義関数を定義するようになると、最低限、利用者を意識したコメントが必要になってくる
- これらの情報は別個の仕様書として用意しても構わないが、そのドキュメントは大概陳腐化する。
- Pythonは関数／型の仕様をコード内のコメントとして記述するための仕組みを用意している。**docstring**(ドックストリング)と呼ばれる構文です。

#### 📒 9.5.1 docstringの基本

- docstringは単なる複数行コメントです。'''～'''、"""～"""で表す。
- 記述場所が限定されている。
  - def/classブロックの先頭に記述する、別のコードが挟まると、正しく認識しないので要注意。
- docstringは決まった形式ではないが、見本にすべきスタイルはいくつか存在するので、以下の慣例に沿うことを勧める。
  - [Googleスタイル](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html)
  - [NumPyスタイル](https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard)
  - [reStructuredText](https://www.sphinx-doc.org/en/master/usage/restructuredtext/)

#### 📒 9.5.2 ドキュメント生成ツール「Sphinx」

- Sphinxのインストール
  - pip install -U sphinx
- ドキュメント生成の準備を行う
  - Sphinxdではドキュメントを生成するためのコマンド類自動生成するためにsphinx-quickstartコマンドが用意されている。
  - 「chap09/mysphinx」ディレクトリで「sphinx-quickstart docs」とコマンドを実行してみよう。
  - sphinx-apidoc -f -o ./docs .
  - sphinx-build -b html ./docs ./docs/\_build
