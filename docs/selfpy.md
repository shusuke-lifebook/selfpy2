# 📒 独習 Python 第 2 版

## 📒 第 1 章 イントロダクション

### 📒 1.1.5 Python ライブラリ

- Python は「Battery Included」(電池付きで、そのまま使える)という思想もとので設計されており、このライブラリが標準で贅沢に用意されている。
- [PyPI(Python Package Index)](https://pypi.org)
  - 拡張ライブラリの集積場ともいうべきサービス

### 📒 1.2.2 Python 開発の状況

- Python の実装には PyPy、IronPython、Jython などがあるが、中でも有名は実装が**CPython**である。
- 非営利団体である[**Python ソフトウェア財団**](https://www.python.org/psf/)が管理している。[オープンソース](https://github.com/python/cpython/)として提供される。

## 📒 第 2 章 Python の基礎

### 📒 2.1 変数

**変数**とは一言で表すと「データの入れ物」です。

#### 📒 2.1.1 変数の宣言

- スクリプト上で変数に初めて値を格納したタイミグで、変数のための領域が自動的にメモリ上に確保される。

#### 📒 2.1.2 識別子の命令規則

1. Unicode 文字を利用できる(ただし、アンダースコア以外の記号、句読点、絵文字などは不可)
2. 1 文字目は数字以外であること
3. アルファベットの大文字／小文字は区別される。
4. 予約語でないこと
5. 文字数の制限はない

#### 📒 2.1.3 よりよい識別のためのルール

#### 📒 2.1.4. 変数の破棄

- del 命令を利用することで、宣言済みの変数を破棄することができる。

#### 📒 2.1.5. 定数

- あとから中身を変更できない入れ物のことを**定数**と呼ぶ
- Python 自体には定数という仕組みはない。すべて大文字の名前とすることで、一般的な変数と区別する。

#### 📒 2.2 データ型

- **データ型(型)**とは、データの種類のこと。
- Python はデータ型に対して寛容。(動的型付け)

#### 📒 2.2.1 データ型の種類

| 分類       | 型       | 概要                       | 変更可能 | 反復不可 | 順序 |
| :--------- | :------- | :------------------------- | :------- | :------- | :--- |
| 数値       | int      | 整数型                     | ×        | ×        | ×    |
| 数値       | float    | 浮動小数点型               | ×        | ×        | ×    |
| 数値       | complex  | 複素数型                   | ×        | ×        | ×    |
| データ     | str      | 文字列型                   | ×        | 〇       | 〇   |
| データ     | bytes    | バイナリデータ             | ×        | 〇       | 〇   |
| コンテナー | list     | 順序を持つリスト           | 〇       | 〇       | 〇   |
| コンテナー | tuple    | 順序を持つリスト(変更不可) | ×        | 〇       | 〇   |
| コンテナー | dict     | キー／値の辞書             | 〇       | 〇       | 〇   |
| コンテナー | set      | 順序を持たない値の集合     | 〇       | 〇       | ×    |
| その他     | bool     | 論理型(True または False)  | ×        | ×        | ×    |
| その他     | NoneType | 値がない                   | ×        | ×        | ×    |

#### 📒 2.2.2 論理型(bool)

- 論理型は、組み込み型の中でも、最も単純な型で、真(正しい)か偽(間違い)か、いずれの状態しか持ちません。
- True/False というキーワードで表現できます。
- Python では論理値を必要とする状況で以下を自動的に False とみなす。
  - 空値(None)
  - 数値のゼロ(0、0.0、0J など)
  - 文字列、空のリストなど(",(),[],set(),range(0)など)

#### 📒 2.2.3 整数型(int)

- 整数リテラル
  - 10 進数リテラル　・・・　-13, 108, 0
  - 16 進数リテラル　・・・　 0xff,0xA3C1
  - 8 進数リテラル　・・・　 0o666, 0o124
  - 2 進数リテラル　・・・　 0b1101, 0b100

#### 📒 2.2.4 浮動小数点(float)

- 一般的な小数点(1.41421356)のようなものだけではなく、指数表現が存在する
- **指数表現とは**
  - <仮数部> e <符号> <指数部>
  - <仮数部> x 10 の<符号><指数部>
    - <例> 1.4142e10 ➡ 1.414 x 10 の 10 乗
    - <例> 1.173205e-7 ➡ 1.173205 x 10 の -7 乗

#### 📒 2.2.5 数値セパレータ

- Python 3.6 以降では、桁数の大きな数値の可読性を改善するため、数値リテラルの中に桁区切り文字(\_)を記述する。
- **数詞セパレータ**
  - 例) value = 1_234_567

#### 📒 2.2.6 複素数型(Complex)

- 複素数(虚数)とは数学上の概念的な値で、
  - **<実部> + <虚部>j** の形式で表す。

#### 📒 2.2.7 文字列型(str)

- 文字列リテラルを表現するには、文字全体をシングルクォート(')、または、ダブルクォート(")でくくる。
- フォーマット文字列
  - Python3.6 以降では、文字列リテラルの先頭に「f」、または「F」をつけることで、文字列の中に{...}の形式で埋め込むことができる。

#### 📒 2.2.8 リスト(list)

- **リスト**には複数の値を収めることができる。リストとは仕切りのある入れ物だと考えてもよい。
- 仕切りで区切られたスペース(**要素**と言います)
- 言語によっては、**配列**(array)と呼ばれることもある。

## 📒 3. 演算子

- **演算子(オペレータ)**とは、与えられた変数やリテラルに対して、あらかじめ決められた処理を行う処理です。
- 演算子によって処理される変数／リテラルのことを**被演算子(オペランド)**と呼ぶ
- Python 演算子は大きく以下に分かれる。
  - 算術演算子
  - 代入演算子
  - 比較演算子
  - 論理演算子
  - ビット演算子

### 📒 3.1 算術演算子

- **代数演算子**ともいう。四則演算をはじめ、日常的な数学で利用する演算子を提供する。

| 演算子 | 概要               | 例              |
| :----- | :----------------- | :-------------- |
| +      | 加算               | 2 + 3 ➡ 5       |
| -      | 減算               | 5 -2 ➡ 3        |
| \*     | 乗算               | 2 \* 4 ➡ 8      |
| \*\*   | べき乗             | 2 \*\* 3 ➡ 8    |
| /      | 除算               | 7 / 3 ➡ 2.33... |
| //     | 除算(切り捨て)     | 7 // 2 ➡ 3      |
| %      | 剰余(割ったあまり) | 10 % 3 ➡ 1      |

### 📒 3.2 代入演算子

- 左辺で指定した変数に対して、右辺の値を設定(代入)するための演算子です。

| 演算子 | 概要                                                   | 例                        |
| :----- | :----------------------------------------------------- | :------------------------ |
| =      | 変数などに値を代入                                     | x = 10                    |
| +=     | 左辺と右辺を加算した結果を、左辺に代入                 | x = 5; x += 2 ➡ x = 7     |
| -=     | 左辺と右辺の差を、左辺に代入                           | x = 5; x -= 2 ➡ x = 3     |
| \*=    | 左辺と右辺の積を、左辺に代入                           | x = 5; x \*= 2 ➡ x = 10   |
| /=     | 左辺と右辺の商を、左辺に代入                           | x = 5; x /= 2 ➡ x = 2.5   |
| //=    | 左辺と右辺の商を、左辺に代入                           | x = 5; x //= 2 ➡ x = 2    |
| %=     | 左辺と右辺の商のあまりを、左辺に代入                   | x = 5; x %= 2 ➡ x = 1     |
| \*\*=  | 左辺と右辺のべき乗を、左辺に代入                       | x = 5; x \*\*= 2 ➡ x = 25 |
| &=     | ビット演算子の論理積(AND)した結果を左辺に代入          | x = 5; x &= 2 ➡ x = 0     |
| ^=     | ビット演算子の排他論理和(XOR)(XOR)した結果を左辺に代入 | x = 5; x ^= 2 ➡ x = 7     |
| \|=    | ビット演算子の論理和(OR)した結果を左辺に代入           | x = 5; x \|= 2 ➡ x = 7    |
| >>=    | ビット演算子の右シフトした結果を左辺に代入             | x = 5; x >>= 2 ➡ x = 1    |
| <<=    | ビット演算子の左シフトした結果を左辺に代入             | x = 5; x <<= 2 ➡ x = 20   |

#### 📒 3.2.4 アンパック代入

- **アンパック代入**とは、リスト／辞書などを分解し、配下の要素を個々の変数に分解する構文のこと。

```Python
data = [1, 2, 3, 4, 5]
a, b, c, d, e = data
print(a)
print(b)
print(c)
print(d)
print(e)

```

#### 📒 3.2.5 新しい代入演算子 「:=」

- Python でも代入「式」を書けるように、Python3.8 で導入されたのが「:=」演算子です。
- 横に倒れたセイウチの顔に似ていることから、セイウチ演算子とも呼ばれる。

```Python
y = (x := 20) / 10
```

#### 📒 3.3 比較演算子

- **比較演算子**は左辺と右辺を比較し、その結果を True/False として返す。

| 演算子   | 概要                                        | 例                       |
| :------- | :------------------------------------------ | :----------------------- |
| <        | 左辺が右辺より小さい場合に True             | 5 < 10 ➡ True            |
| >        | 左辺が右辺より大きい場合に True             | 5 > 10 ➡ False           |
| ==       | 左辺と右辺が等しい場合に True               | 5 == 5 ➡ True            |
| <=       | 左辺が右辺以下である場合に True             | 5 <= 10 ➡ True           |
| >=       | 左辺が右辺以上である場合に True             | 5 >= 10 ➡ False          |
| !=       | 左辺と右辺が等しくない場合に True           | 5 != 10 ➡ True           |
| is [not] | 左辺と右辺のオブジェクトが等しい場合に True | [1, 2] is [1, 2] ➡ False |
| [not] in | 左辺が右辺に含まれているか(いないか)        | 3 in [1, 2, 3] ➡ True    |

#### 📒 3.3.1 異なる型での比較

- 「＜」、「＞」などの大小比較では、異なる型同士での比較はエラーです。
- 対して、「==」「!=」演算子はことなる型同士でも比較できる。ただし、一般的には False を返す。

#### 📒 3.3.2 リストの比較

- リスト同士の比較にも、比較演算子は利用できる。リストの比較といっても、考え方は文字列のそれと同じです。
- 先頭から要素を比較していき、最初に異なる要素が見つかった場合に、その大小を決定する。

```Python
data1 = [1, 2, 3]
data2 = [1, 5]
data3 = [1, 2]

print(data1 < data2)
print(data1 < data3)
```

#### 📒 3.3.3 浮動小数点の比較

- 浮動小数点を比較にするには、以下のような方法を利用する。
  - (1) Decimal 型
    - Decimal 型は厳密な浮動小数点の演算/比較を可能にする
  - (2) 丸め単位による比較
    - 比較に限定するならば、以下のような方法も利用できる。

    ```Python
    EPSILON = 0.00001
    x = 0.2 * 3
    y = 0.6
    print(abs(x-y) < EPSILON)
    ```

  - (3) isclose 関数
    - math モジュールの isclose 関数を利用することで、(2)のよな近似比較をシンプルに表現できる
      - rel_to: 相対誤差。2 つの値のうち、絶対値の大きい値に対する割合で指定
      - abs_to: 絶対誤差。許容する誤差を絶対値で指定。

    ```Python
    import math

    print(math.isclose(0.2 * 3, 0.6))
    print(math.isclose(0.1, 0.1001, rel_tol=0.0001)) # False
    print(math.isclose(0.1, 0.1001, rel_tol=0.001)) # True

    ```

#### 📒 3.3.4 同一性と同値性

- 比較演算子を利用する上で、**同一性**と**同値性**を区別することは重要。
  - 同一性： 参照値が同じオブジェクトを参照していること
  - 同値性： オブジェクトが同じ値を持っていること

#### 📒 3.3.5 条件演算子

- **条件演算子**は指定された条件の真偽に応じて対応する式を返す。

### 📒 3.4 論理演算子

- **論理演算子**は複数の条件式を論理的に結合しその結果を True/False を返す。

| 演算子 | 概要                                                | 例              |
| :----- | :-------------------------------------------------- | :-------------- |
| and    | 論理積。左右の式がともに True の場合に True         | x and y ➡ False |
| or     | 論理和。左右の式のどちらかが True の場合に True     | x or y ➡ True   |
| ^      | 排他論理和。左右の式が異なる場合に True             | x ^ y ➡ True    |
| not    | 否定。式が True の場合は False、False の場合は True | not x ➡ False   |

#### 📒 3.4.1 ショートカット演算(短絡演算)

- 論理積/論理和演算では、「ある条件のもとにでは、左式だけが評価されて右式が評価されない」場合がある。このような演算のことを**ショートカット演算**、あるいは**短絡演算**と呼ぶ。

#### 📒 3.4.2 比較演算子の連結

- Python は比較演算子の連結を認めているため、以下のような記載ができる

```Python
50 <= x <= 100
```

### 📒 3.5 ビット演算子

- **ビット演算**とは、整数を 2 進数で表したときの各桁(ビット単位)を論理計算する演算のことです。

| 演算子    | 概要                                                            | 例                                 |
| :-------- | :-------------------------------------------------------------- | :--------------------------------- |
| &         | 論理積。左式/右式の双方にセットされているビットをセット         | 10 & 1 ➡ 1010 & 0001 ➡ 0000 ➡ 0    |
| \|        | 論理和。左式/右式のどちらかがセットされているビットをセット     | 10 \| 1 ➡ 1010 \| 0001 ➡ 1011 ➡ 11 |
| ^         | 排他論理和。左式/右式のどちらかがセットされているビットをセット | 10 ^ 1 ➡ 1010 ^ 0001 ➡ 1011 ➡ 11   |
| ~(チルダ) | 否定。ビットを反転                                              | ~10 ➡ ~1010 ➡ 0101 ➡ -11           |
| <<        | ビットを左にシフト                                              | 10 << 1 ➡ 1010 << 1 ➡ 10100 ➡ 20   |
| >>        | ビットを右にシフト                                              | 10 >> 1 ➡ 1010 >> 1 ➡ 101 ➡ 5      |

### 📒 3.6 演算子の優先順位と結合則

- 式に複数の演算子が含まれている場合、これらがどのよな順序で処理されるかを知っておくことは重要。
- このルールを規定したおのが、演算子の**優先順位**と**結合則**です。

## 📒 4. 制御構文

- 一般的に、プログラムの構造は以下のように分類できる。
  - **順次(順接)**: 記述されら順番に処理を実行
  - **選択**: 条件によって処理を分岐
  - **反復**: 特定の処理を繰り返し実行

### 📒 4.1 条件分岐

- 実際のアプリケーションでは、ユーザーからの入力や実行環境、その他の条件に応じて、処理を切り替えるのが一般的です。

#### 📒 4.1.1 if 命令 - 単純分岐

- if は、与えられた条件が True/False いずれかによって、実行すべき処理を決める命令です。

```Python
# if 命令
if 条件式:
  ...条件式がTrueのときに実行する処理...
else:
  ...条件式がFalseのときに実行する処理...
```

#### 📒 4.1.2 if 命令 - 多岐分岐

- elif ブロックを利用することで、多岐分岐を表現できる。

```Python
if 条件式1:
  ...条件式1がTrueのときに実行する処理...
elif 条件式2:
  ...条件式2がTrueのときに実行する処理...
else
  ...すべての条件式がFalseのときに実行する処理...

```

#### 📒 4.1.3 if 命令 - 入れ子の構造

```Python
i = 0
j = 0

if i == 1:
    if j == 1:
        print("変数i,jは1です。")
    else:
        print("変数iは1ですが、jは1ではありません。")
else:
    print("変数iは1ではありません。")

```

#### 📒 4.1.4 補足 条件式を指定する場合の注意

#### 📒 4.1.5 match...case 命令 (Python3.10)

- match..case 構文は与えられた式と値を比較しマッチしたブロックを選択的に実行する。

```Python
match 式:
  case パターン1:
    ...「式」と「パターン1」がマッチした場合に実行する処理...
  case パターン2:
    ...「式」と「パターン2」がマッチした場合に実行する処理...
  ...
```

### 📒 4.2 繰り返し処理

- Python では、while/for といった繰り返し処理が用意されており、条件式、リスト、指定回数などに基づいて繰り返し処理を実行できる。

#### 📒 4.2.1 条件式が True の間だけ処理を繰り返す - while 命令

- while 命令を利用することで、条件式が True である間だけ、配下の処理を繰り返すことができる。

```Python
while 条件式:
  ...条件式がTrueのときに実行する処理...

```

#### 📒 4.2.2 リストの内容を順に処理する - for 命令

- for 命令を利用することで、リスト／辞書などから順に要素を取り出し、決められた処理を実行することできる。

```Python
for 仮変数 in list:
  ...個々の要素を処理するコード...

```

#### 📒 4.2.3 決められた回数だけ処理を実行する。 - for 命令(range 関数)

- リストを擬似的に作成し(range 関数)で、決められた回数だけ処理を実行する。

```Python
for i in range(1, 6):
    print(f"{i}番目のループです。")
```

#### 📒 4.2.4 リストから新たなリストを生成する - リスト内包表記

- **内包表記**とは、既存のリストから新たなリストを生成する際に簡単に書ける表現方法です。

```Python
[式 for 仮変数 in リスト]
```

### 📒 4.3 ループの制御

- while／for 命令ではいずれも、あらかじめ決められた終了条件を満たしたタイミングで、ループを終了します。
- 処理によっては特定の条件を満たしたところで、強制的にループを中断したい、あるいは特定の周回だけスキップしたいこともある。
- Python では break/continue というループ制御構文が用意されている。

#### 📒 4.3.1 ループを中断する - break 命令

- break 命令を使用すると、for/while 本来の終了条件にかかわらず、繰り返し処理を中断できる。

```Python
sum = 0

for i in range(1, 101):
    sum += i
    if sum > 1000:
        break

print(f"合計が10000を超えるのは、1～{i}を加算したときです。")

```

#### 📒 4.3.2 現在の周回をスキップする - continue 命令

- 現在の周回だけをスキップし、ループそのものは継続して実行するのが、continue 命令の役割です。

```Python
sum = 0

for i in range(1, 101):
    if i % 2 != 0:
        continue
    sum += i

print(f"合計値は{sum}です。")

```

#### 📒 4.3.3 ループでの終了処理を実行する。

- Python では、else 節を while/for 命令でも利用できる。while/for 節の else 節は
  - **break せずにループを終了した場合に実行する処理**を表す。

#### 📒 4.3.4 入れ子のループ中断／スキップする

### 📒 4.4 例外処理

- アプリ開発していくと、さまざまな問題(エラー)に遭遇する。エラーはさらに、**アプリとして事前に対処できるかどうか**によって以下の 2 種類に大別できる。
  - (1) 構文エラー
  - (2) 例外

#### 📒 4.4.1 例外処理をする - try 命令

- 例外処理とは、あらかじめ発生する**かもしれない**エラーを想定しておき、実行を継続できるように処理する。

```Python
try:
  ...例外が発生するかもしれないコード...
except 例外の種類 as 例外変数:
  ...例外発生時の処理...
```

#### 📒 4.4.2 例外が発生した場合、しなかった場合の処理を定義する

- try ... except 構文では、後処理を行う節として、else/finally を用意している。

```Python
try:
  ...例外が発生するかもしれないコード...
except 例外の種類 as 例外変数:
  ...例外発生時の処理...
else:
  ...例外が発生しなかったときの処理...
finally:
  ...例外の有無にかかわらず実行する処理...
```

## 📒 5. 標準ライブラリ

- Python では、標準的な言語機能に加えて、コードから自在に呼び出させる命令(群)をあまた提供している。このような命令を**ライブライ**と呼び、Python を学ぶ場合には、ライブラリの用法も含めて理解が欠かせない。

### 📒 5.1 ライブラリの分類

- Python では、さまざま形でライブラリを提供されている。
- ライブラリを提供している機能は、大まかに以下の観点から分類できる。
  - (1) 型と関数
  - (2) 組み込みライブラリとモジュール

#### 📒 5.1.1 関数

**関数**とは、何かしら入力(パラメーター)を与えることによって、あらかじめ決まった処理を行い、その結果を返す仕組みのこと。

- 関数への入力のことを**引数**
- 出力のこととを**戻り値**

#### 📒 5.1.2 型

- **型(データ)**は、コードの中で扱える値の種類を決めるための仕組みです。
- 型をより専門的な用語では**クラス**という。
- 型に対して具体的な値を与えて、コードの中で利用できるようにすることを**インスタンス化**と呼ぶ。
- クラスメソッド／クラス変数に対して、インスタンス経由で呼び出すメソッド／変数のことを**インスタンスメソッド**、**インスタンス変数**と呼ぶ
  - インスタンスメソッド／変数は、インスタンスの情報を取得／操作するためのもの
  - クラスメソッド／変数は、クラスの情報を取得／操作するもの

#### 📒 5.1.3 組み込み型／関数とモジュール

- モジュールに属する型、関数を利用する際には、まず対象のモジュールを読み込む必要がある。
- これを**インポート**と言う。インポートには、import という命令を利用する。

```Python
import モジュール名
```

- **特定のメンバーだけをインポートする**
  - 「import module」では、モジュール内のすべてのメンバーをインポートする。
  - from ... import 命令を利用することで、モジュール内の特定の関数／クラス(型)だけをインポートすることもできる。

```Python
from module import member ...

module: モジュール名
member: 関数/クラス名
```

### 📒 5.2 文字列の操作

#### 📒 5.2.1 文字列の長さを取得する

- 文字列の長さを取得するには、組み込み関数の len を利用する。
- len 関数では、日本語(マルチバイト文字)も正しく 1 文字としてカウントする。
- もしも半角を 1 文字、全角を 2 文字としてカウントしたいならば、unicodedata モジュールの east_asian_width 関数を利用する。

#### 📒 5.2.2 文字列の大文字 ⇔ 小文字で変換

- 文字列の大文字／小文字に変換するメソッドには以下のようなものがある。
  |メソッド|概要|
  |:---|:---|
  |lower()|大文字 ➡ 小文字に変換|
  |upper()|小文字 ➡ 大文字に変換|
  |swapcase()|大文字と小文字を反転|
  |capitalize()|先頭文字を大文字に、以降を小文字に変換|
  |title()|単語の先頭文字を大文字に、それ以降を小文字に変換|
  |casefold()|大文字小文字の区別を除去|

#### 📒 5.2.3 部分文字列を取得する

- 文字列から部分的な文字列を取り出すには、インデックス／スライス構文を利用する。

```Python
txt[index]
txt[start:end:step]

txt: 文字列
index: インデックス番号
start: 開始位置
end: 終了位置
step: ステップ(増減)
```

#### 5.2.4 文字の種類を判定する

- 文字列に含まれる文字の種類を判定するには、isxxxxx メソッドを利用する。
  |メソッドの種類|概要|
  |:---|:---|
  |isalnum()|英数字であるか|
  |isalpah()|英字であるか|
  |isascii()|ASCII 文字であるか|
  |isdecimal()|10 進数値であるか|
  |isdigit()|数値であるか|
  |isnumeric()|数値文字であるか|
  |isidentifier()|有効な識別子であるか|
  |islower()|小文字であるか|
  |isupper()|大文字であるか|
  |istitle()|単語の先頭文字だけが大文字であるか|
  |isprintable()|印字可能な文字か否か|
  |isspace()|空白文字であるか|
- **文字列を数値に変換する**
  - unicodedata モジュールの digit/numeric 関数を利用する
- **予約済みの識別子を確認する**
  - isidentifier メソッドは与えられた文字列が識別子として認められている文字のみで構成されているかを判定する。
  - 文字列が予約済みの識別子であるか判定する場合、keyword モジュールの iskeyword 関数を利用する。

#### 📒 5.2.5 文字列を検索する

- 特定の文字列が登場する文字位置を取得するには、find/rfind メソッドを利用する。

```Python
s.find(sub ,[start, end])
s.rfind(sub, [start, end]])

s: 元の文字列
sub: 検索文字列
start: 検索開始位置
end: 検索終了位置

```

- **例外を返す index/rindex メソッド**
  - 検索文字列が見つからなかった場合に例外(ValueError)を返すのが index/rindex メソッド。
  - 構文は find/rfind メソッドと同じ。
- **部分文字列の登場回数をカウントする**
  - 文字位置を検索する find/index メソッドに対して、count メソッドを利用することで、部分文字列が登場する回数をカウントすることもできる。

```Python
s.count(sub, [start, end])
s: 元の文字列
sub: 検索文字列
start: 検索開始位置
end: 検索終了位置
```

#### 📒 5.2.6 文字列の前後から空白を除去する

- strip/lstrip/rstrip メソッドを利用することで、文字列前後の空白を除去できる。
  - strip メソッドは前後の双方の空白
  - lstrip は前方だけ
  - rstrip は後方だけ

```Python
s.strip([chars])
s.lstrip([chars])
s.rstrip([chars])

s: 元の文字列
chars: 除去する文字群
```

#### 📒 5.2.7 文字列に特定の文字列が含まれているか判定する

- 文字列の指定された部分文字列が含まれるかを判定するには、in 演算子を利用する。
- ある文字列が先頭／末尾に位置するかを判定するならば、startswith/endswith メソッドも利用できる。

```Python
substr in s
s.startswith(prefix[, start[,entd]])
s.endswith(suffix[, start[, end]])

s: 元の文字列
substr/prefix/suffix: 検索文字列
start: 検索開始位置
end: 検索終了位置

```

#### 📒 5.2.8 文字列を特定の区切り文字で分割する

- **一般的な分割 split／rsplit**

```Python
s.split(sep=None, maxspilt=-1)
s.rsplit(sep=None, maxsplit=-1)

s: 元の文字列
sep: 区切り文字列
maxsplit: 最大分割数

```

- **改行文字で分割する --splitlines メソッド**
- **区切り文字で文字列を 2 分割する**

#### 📒 5.2.9 リストを結合する

- リストは、join メソッドを利用することで、指定の区切り文字で連結できます。

```Python
joinメソッド

s.join(iterable)

s:区切り文字
iterable: 連結対象のリスト
```

#### 📒 5.2.10 文字列を置き換える

- 文字列に含まれる特定の部分文字列を別の文字に置き換えるには、replace メソッドを利用する。

```Python
s.replace(old, new[, count])
s: 元の文字列
old: 置き換える部分文字列
new: 置き換え後の文字列
count: 置き換える個数
```

- **特定の文字を変換／削除する**
  - 表記をそろえるなどの目的で、文字列に含まれる特定の文字(群)を変換／削除したいというケースがある
  - replace よりも translate メソッドを利用することをお勧めする
  - translate メソッドは引数に変換ルールを受け取る。変換ルールを作成するのは、str.maketrans メソッドを利用する。

  ```Python
  str.maketrans(dict)
  str.maketrans(old, new[, no])

  dict:「変換前：変換後」の辞書
  old: 変換前の文字群
  new: 変換後の文字群
  no: 除去する文字群
  ```

#### 📒 5.2.11 文字を整形する

- format メソッドを利用することで、指定された書式文字列に基づいて文字列を整形できる。

```Python
txt.format(*args, **kwargs)

txt: 書式文字列
args: 書式に割り当てる値(可変変数)
kwargs: 書式に割り当てる値(キーワード引数)
```

#### 📒 5.2.12 str 型 ⇔bytes 型を変換する

- Python では、受け渡しのためのエンコーディング情報を管理しており、その情報に基づいて文字列をエンコード変換している。
- 文字列を別のアプリとやりとりするようになると、文字エンコーディングを意識して明示的にエンコードしなければならない状況がでる。これを行うのが、encode メソッドです。

```Python
txt.encode(encoding='utf-8', errors="strict")

txt: 任意の文字列
encoding: 変換に利用するエンコーディング
errors: エラー時の挙動
```

- Python で bytes 型の値を str 型に戻すには、decode メソッドを利用する

```Python
bs.decode(encoding='utf-8', errors="strict")

bs: 任意のバイト列
encoding: 変換に利用するエンコーディング
errors: エラー時の挙動
```

| 設定値  | 概要                                           |
| :------ | :--------------------------------------------- |
| strict  | エラー(例外)を発生させて処理を中止             |
| ignore  | 変換できない文字は除去して、そのまま処理を継続 |
| replace | 変換できない文字は「?」などに置換              |

### 5.3 日付/時刻の操作

- 組み込まれていないもので、アプリ開発でよく利用するのが日付／時刻値です。
- Python で日付／時刻値を扱うには、datetime モジュールを利用するのが基本です。
  |型|概要|
  |:---|:---|
  |datetime|日付／時刻値|
  |date|日付値|
  |time|時刻値|
  |timezone|タイムゾーン情報|
  |timedelta|時間間隔|

#### 📒 5.3.1 日付／時刻値を生成する。

- datetime モジュールは日付／時刻値を生成／初期化するために様々な方法を用意している。
  |メソッド|概要|
  |:---|:--|
  |datetime.today()|現在の日時|
  |date.today()|今日の日付|
  |datetime.now()|現在の日時(タイムゾーン付き)|

```Python
timezone(ofset)
ofset: 時差(timedelta型)

ZoneInfo(key)
key: タイムゾーンの名前

```

- **指定された年月日、時分秒から生成する**
  - datetime/date/time 型は、それぞれ以下のようにインスタンス化できる。

  ```Python
  datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)
  date(year, month, day)
  time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None)

  year: 年
  month: 月
  day: 日
  hour: 時
  minute: 分
  second: 秒
  microsecond: マイクロ秒
  tzinfo: タイムゾーン情報
  fold: 夏季時間を加味するか
  ```

- **日付／時刻を文字列から変換する**
  - strptime メソッドを利用することで、文字列から日付／時刻値を datetime オブジェクトを生成できる。

  ```Python
  datetime.strptime(date_string, format)

  date_string: 日付文字列
  format: 解析に利用する書籍
  ```

- **タイムスタンプから生成する**

```Python
datetime.fromtimestamp(timestamp, tz=None)
date.fromtimestamp(timestamp)

timestamp: タイムスタンプ値
tz: タイムゾーン
```

- **一部の要素を書き換えた日付を生成する**

```Python
dt.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzionfo, *, fold=0)
dat.replace(year=self.year, month=self.month, day=self.day)
tim.replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, *, fold=0)

dt: datetimeオブジェクト
dat: dateオブジェクト
tim: timeオブジェクト
year: 年
month: 月
day: 日
hour: 時
minute: 分
second: 秒
microsecond: マイクロ秒
tzinfo: タイムゾーン
fold: 夏季時間を加味するか
```

#### 📒 5.3.2 年月日、時分秒などの時刻要素を取得する

| 属性        | 概要                     |
| :---------- | :----------------------- |
| year        | 年                       |
| month       | 月(1 ～ 12)              |
| day         | 日(1 ～ 31)              |
| hour        | 時(0 ～ 23)              |
| minute      | 分(0 ～ 59)              |
| second      | 秒(0 ～ 59)              |
| microsecond | マイクロ秒(0 ～ 999999)  |
| tzinfo      | タイムゾーン(timezon 型) |

| メソッド      | 概要                                                         |
| :------------ | :----------------------------------------------------------- |
| date()        | 日付部分を取得                                               |
| time()        | 時刻部分を取得(native)                                       |
| timetz()      | 時刻部分を取得(aware)                                        |
| timestamp()   | タイムスタンプ値を取得                                       |
| toordinal()   | 西暦 1 年 1 月 1 日からの通算日                              |
| weekend()     | 曜日を取得(0:月～ 6:日)                                      |
| isoweekday()  | 曜日を取得(1:月～ 7:日)                                      |
| isocalender() | (year=年,week=週番号,weekday=曜日)形式の名前付きタプルを取得 |

#### 📒 5.3.3 日付／時刻値を加算／減算する

```Python
dt + delta
dt - delta

dt: 日付／時刻値(datetime/date/time)
delta: 加算／減算する時間(timedelta)
```

```Python
timedelta(days=0, weeks=0, hours=0, minutes=0, seconds=0, microseconds=0, millseconds=0)

days: 日数
weeks: 週数
hours: 時間数
minutes: 分数
seconds: 秒数
microseconds: マイクロ秒数
millseconds: ミリ秒数
```

#### 📒 5.3.4 日付／時刻値の差分を求める

- datetime/date/time 同士では「-」演算を利用することで、互いの差を求めることができる。

```Python
dt1 - dt2

dt1/dt2: 日付／時刻値(datetime／date／time)
```

#### 📒 5.3.5 日付／時刻値を比較する

- 「<」「>」などの比較演算子を利用することで、日付／時刻のいずれかの過去／未来かを判定することが可能

#### 📒 5.3.6 日付／時刻を整形する

- 日付／時刻値を整形するには、strftime メソッドを利用する。

```Python
dt.strftime(format)

dt: 日付／時刻値(datetime/date/time)
format: 書式文字列
```

- strftime メソッドはロケール(地域)情報によって変動する。最初に setlocale メソッドで明示的にロケールを設定する。

```Python
setlocale(category, locale=None)

category: 設定する対象
locale: ロケール値
```

#### 📒 5.3.7 カレンダーを生成する

- カレンダーの生成に特化した calender モジュールを利用して生成する。

## 📒 6. 標準ライブラリ

- 型の中でも複数の値を束ねるための仕組みを持つものを相称して、**コレクション、コンテナー**などと呼ぶ
  - シーケンス型
    - インデックスで管理
    - 値の重複は OK
  - セット(集合)型
    - 順番は持たない
    - 値の重複は NG
  - 辞書(マッピング)型
    - キーと値のペアで管理
    - キーの重複は NG

### 📒 6.1 シーケンス型

- リスト(list)
- タプル(tuple)
- レンジ(range)

#### 📒 6.1.1 リストの生成

1. list リテラル
2. リスト内包表記
3. list コンストラクタ
4. リストを返す関数／メソッド(sorted 関数、split 関数など)

```Python
list([iterable])

iterable: イテラブル型
```

#### 📒 6.1.2 リストから特定の範囲の要素を取得する - スライス構文

- リストから特定の範囲の要素を取り出すには、スライス構文を利用する。

```Python
lists[start:end:step]

lists: リスト
start: 開始位置
end: 終了位置
step: ステップ(増減)
```

#### 📒 6.1.3 リストの要素数を取得する

- len 関数でリストに含まれる要素の数を取得できる。

```Python
len(list)

list: 対象のリスト
```

#### 📒 6.1.4 リストに要素を追加／削除する

- リストに要素を追加／削除するには以下のようなメソッドを利用する

```Python
append／insert／popメソッド

lists.append(x) ➡ 末尾に追加
lists.insert(i, x) ➡ i番目の直前に追加
lists.pop([i]) ➡ i番目を削除

lists: 任意のリスト
x: 追加する値
i: 挿入／削除箇所を表すインデックス番号
```

- **スタック構造**
  - **スタック**とは、**後入れ先出し** または **先入れ後出し**と呼ばれる構造

#### 📒 6.1.5 リスト内の要素を削除する

- リストから指定された要素を削除するには remove メソッドを、すべての要素を削除するには clear メソッドを利用する。

```Python
lists.remove(x)
lists.clear()

lists: 任意のリスト
x: 削除する要素
```

#### 📒 6.1.6 複数要素を追加／置換／削除する

- スライス構文を利用することでリストの任意の場所に要素を追加したり、既存の要素を置き換えたり、あるいは削除したりといったコードを短いコードで実施できる。

```Python
data = ["あ", "い", "う", "え", "お"]
data[1:3] = ["1", "2", "3"]
# data[2:4] = []
# del data[2:4]
# data[1:1] = ['1', '2', '3']
# data[1:1] = '987'
print(data)

```

#### 📒 6.1.7 リストを検索する

- リストの中で特定の要素が登場するインデックス位置を取得するには、index メソッドを利用する。

```Python
lists.index(elem[,start[,end]])

lists: 任意のリスト
elem: 検索する要素
start: 検索開始位置
end: 検索終了位置
```

- **要素の登場回数をカウントする**
  - count メソッドを利用することで、同一の要素が登場する回数をカウントすることができる

```Python
list.count(elem)

lists: 任意のリスト
elem: 検索する要素
```

- **要素の有無を確認する**
  - 要素の有無を確認するだけであれば、in 演算子を利用する。

#### 📒 6.1.8 リストを複製する

- copy メソッドで利用して複製することできる
- **シャローコピー**
  - copy メソッドは**シャローコピー**、配下の要素がミュータブルである場合、コピー先の変更はコピーもとに影響する
- **ディープコピー**
  - copy モジュールの deepcopy 関数を利用する。

#### 📒 6.1.9 リストを連結する

- リストを連結するには、文字列と同じく「+」「\*」演算子を利用する
- 既存のリストを拡張する
  - 「+」「\*」演算子は新たなリストを生成するが、既存のリストに対して、要素を連結したいという場合がある。これは extend メソッドを利用する。(または +=)

#### 📒 6.1.10 リストの内容を並び替える

- sort／reverse メソッドなどを利用する
- 並びを逆順にする
  - 並びを逆順にするだけであれば、reverse メソッドを利用する。
  - reverse メソッドと reversed 関数の違い
    - reverse メソッドが現在のリストに影響を及ぼすに対して、reserved 関数は逆順に並び替えた結果を戻り値として返す。
    - reversed 関数の戻り値はリストではなく、イテレーター
- **リストを昇順／降順にソートする**

```Python
lists.sort(*, key=None, reversed=False)

lists: 任意のリスト
key: ソートに利用するキー
reverse: 逆順にソートするか
```

- **任意のキーで並べ替える**
  - sortメソッドのkeyオプションを利用することで、独自のルールで並べ変えることができる。
  - 例えば、リストを文字数について昇順にする。
- **ソート順を保ちながら要素を挿入する -bisect-**
  - ソート順を保ちながら要素を挿入する場合、要素を挿入するたび、sortメソッドしなおしても構いません
  - 挿入するコードが増えれば面倒かつ抜けの原因となる。
  - bisectモジュールを利用することで、リストの順序を保ちながら新規の要素を挿入できる。
  - bisectとは、**配列二分法アルゴリズムの意味**

  ```Python
  insort(a, x, *, key=None)

  a: 対象のリスト
  x: 挿入する値
  key: ソートに利用するキー
  ```

#### 📒 6.1.11 リストをforループで処理する方法

- enumerate／zipなどを利用したより複雑なリスト処理を紹介する
  - **インデックス番号／値をセットで取り出す**
    - enumerate関数を併用することで、値とインデックス番号を取り出しながらループが可能になる。

      ```Python
      data = ["ぱんだ", "うさぎ", "こあら", "とら"]

      for index, value in enumerate(data):
        print(index, ":", value)
      ```

  - **複数のリストを纏めて処理する**
    - zip関数を利用することで、複数のリストを束ねて処理することが可能

      ```Python
      data1 = ["ぱんだ", "うさぎ", "こあら", "とら"]
      data2 = ["panda", "rabbit", "koala"]

      for d1, d2 in zip(data1, data2):
        print(d1, "=", d2)
      ```

    - **最も要素数の多いリストに合わせて処理する**
      - 最も要素数の多いリストに合わせて処理するばらば、itertoolsモジュールのzip_longest関数を利用する

        ```Python
        import itertools

        data1 = ["ぱんだ", "うさぎ", "こあら", "とら"]
        data2 = ["panda", "rabbit", "koala"]

        for d1, d2 in itertools.zip_longest(data1, data2):
            print(d1, ":", d2)

        ```

#### 📒 6.1.12 リスト内の要素がTrueであるか

- リスト内の要素がTrueであるかを判定するには以下を利用する
  |関数|概要|
  |:---|:---|
  |all(list)|リスト内のすべての要素がTrueであるか|
  |any(list)|リスト内の要素が1つでもTrueであるか|
  |not all(list)|リスト内の要素が1つでもFalseであるか|
  |not any(list)|リスト内のすべての要素がFalseであるか|

#### 📒 6.1.13 リスト内の要素を加工する

- 組み込み関数mapを利用することで、リストから順に要素を取得&加工し、新たなリストを生成する

```Python
map(function, iterable, ...)

function: 要素を加工する処理
iterable: 処理対象のリスト
```

#### 📒 6.1.14 リストの内容を特定の条件で絞り込む

- 組む込み関数filterを利用することで、リストの内容を関数で判定し、その中でTrueと判定された要素だけ取得できる

```Python
filter(function, iterable)

function: 要素のTrue／Falseを判定する処理
iterable: 処理対象のリスト
```

#### 📒 6.1.15 リスト内の要素を順に処理して1つにまとめる

- functoolsモジュールのreduce関数を利用する

```Python
reduce(function, iterable[, initalizer])

function: 要素を演算する処理
iterable: 処理対象のリスト
initializer: 初期値
```

#### 📒 6.1.16 キュー構造を実装する

- キュー(Queue)は、先入れ先出し(FIFO)と呼ばれるデータ構造です。
- 最初に入った要素から順に処理する流れが窓口などでサービスを待つ様子にも似ていることから、**待ち行列**とも呼ばれる
- キュー構造を実装するならば、collections.deque型を利用することを勧める。

```Python
dquer([iterable[, maxlen]])

iteralbe: 元なるデータ(リストなど)
maxlen: 最大長
```

| メソッド      | 概要                  |
| :------------ | :-------------------- |
| append(x)     | 値を末尾に追加        |
| appendleft(x) | 値を先頭に追加        |
| clear()       | すべての値を破棄      |
| pop()         | 末尾から値を取得&削除 |
| popleft()     | 先頭から値を取得&削除 |

#### 📒 6.1.17 イミュータブルなリストを生成する

- **タプル(tuple)**とは、「変更できない(イミュータブル)なリスト」です。

### 📒 6.2 セット(集合)型

- セット(Set)は、リストと違って順番を持たない
- 重複した値も許さない。
- セット
  - set: ミュータブル
  - fronzenset: イミュターブル

#### 📒 6.2.1 セットの生成

```Python
set([iterable])

iterable: セットに収納するリスト／タプルなど
```

- **入れ子のセットを宣言**
  - セットの要素はイミュターブル(より正しくはハッシュ可能)でなければならない。値が一定でなければ重複も判定できないのは当然
  - 入れ子のセットを表現する場合
    - **内側のセットはfrozensetでなけらばならない**

#### 📒 6.2.2 セットの基本操作

-

#### 📒 6.2.3 要素の有無／包含関係を判定する

- 一般的にセットを利用するのは、ある値がすでに存在するか？
- あるセットが別のセットに含まれているか？
- 集合関係に関心がある場合になるでしょう。

- 「<」演算子も利用できるが、こちらは真部分集合を意味する。つまり、「あるセットが別のセットに含まれるが、等しくない」を判定する。

```Python
sets.issubset(other)

sets: 任意のセット
other: 比較のセット
```

- 逆に、セットsetsに別のotherが含まれるかを判定したいならば、issupersetメソッドを利用する

```Python
sets.issuperset(other)

sets: 任意のセット
other: 比較のセット
```

#### 📒 6.2.4 和集合／差集合／積集合などを求める

- | (union: 和集合)
- & (intersection: 積集合)
- \- (difference: 差集合)
- ^ (sysmatic_difference: 対称差集合)

- セット内包表記

```Python
{式 for 仮変数 in イテラブル型 if 条件式}
```

### 📒 6.3 辞書(dict)型

- **辞書(dict)**は、一意のキーと値をペアで管理されるデータ構造。言語によっては**ハッシュ、連想配列**と呼べれる場合もある。

#### 📒 6.3.1 辞書の生成

- 様々な方法で辞書を作成してみよう

```Python
d1 = {"red": "赤", "white": "白", "yellow": "黄"}
print(d1)
d2 = {}
print(d2)
d3 = dict(red="赤", white="白", yellow="黄")
print(d3)
d4 = dict([("red", "赤"), ("white", "白"), ("yellow", "黄")])
print(d4)
d5 = dict({"yellow": "黄", "white": "白", "red": "赤"})
print(d5)
d6 = dict({"red": "赤", "white": "白", "yellow": "黄"}, white="白", black="黒")
print(d6)
d7 = dict(zip(["red", "white", "yellow"], ["赤", "白", "黄"]))
print(d7)
```

#### 📒 6.3.2 ハッシュ表とキーの注意点

- dict(辞書)は内部的に**ハッシュ表(ハッシュテーブル)**と呼ばれるリストを持つ
  - **キーはハッシュ可能であること**
    - 辞書(dict)のキーは、ハッシュ値を算出可能な型でなければならない。このような性質を**hashable(ハッシュ可能)**と呼ぶ
    - 組み込み型では以下のような型がhashableです。
      - int
      - str
      - bytes
      - tuple
      - frozenset

#### 📒 6.3.3 辞書の基本操作

- 辞書の操作方法は、リスト／セットのそれを理解していれば、ごく直観的にわかる。
  - **辞書にキー／値を設定する**
    - 辞書に後からキー／値を追加する場合、ブラケット構文、または、setdefaultメソッドを利用する。
      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      d["apple"] = "林檎"
      d["strawberry"] = "いちご"
      print(d.setdefault("apple", "〇"))
      print(d.setdefault("watermelon", "〇"))
      print(d)
      ```
  - **辞書に複数のキー／値を設定する**
    - 複数のキー／値をまとめて設定するならば、updateメソッドを利用できる
      ```Python
      d1 = {"apple": "りんご", "orange": "みかん"}
      d2 = {"melon": "メロン", "orange": "蜜柑"}
      d1.update(d2)
      print(d1)
      d1.update(strawberry="いちご", watermelon="スイカ")
      print(d1)
      d1.update([("pear", "なし"), ("grape", "ぶどう")])
      print(d1)
      ```
  - **辞書から値を取得する**
    - 辞書から値を取得するには、ブラケット構文をはじめ、get、pop／popitemメソッドが利用できる。
      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      # print(d["pear"])  # エラー KeyError: 'pear'
      print(d.get("pear", "×"))
      print(d.pop("melon", "×"))
      print(d.popitem())
      print(d)
      ```
  - **特定のキーが含まれているかを判定する**
    - 値ではなく、単にキーが存在するかどうかを判定したいだけであれば、in演算子を利用する
      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      print("orange" in d)
      print("pear" in d)
      ```
  - **辞書からキーを削除する**
    - del命令で個別のキーを削除し、clearメソッドですべてのキーを破棄する。
      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      del d["orange"]
      print(d)
      d.clear()
      print(d)
      ```
  - **辞書の内容を列挙する**
    - dictの内容を列挙するには以下のようなメソッドを利用する

      | メソッド | 概要                   |
      | :------- | :--------------------- |
      | items()  | キー／値のビューを取得 |
      | keys()   | キーのビューを取得     |
      | values() | 値のビューを取得       |

      ```Python
      d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      # 項目を列挙
      for item in d.items():
          print(item)

      for key, value in d.items():
          print(key, ":", value)

      # キーを列挙
      for key in d.keys():
          print(key)

      # 値を列挙
      for value in d.values():
          print(value)
      ```

  - **辞書のキーを比較する**
    - keysメソッドの戻り値は、セットと同じく、「&」「|」などの演算子を用いることで積集合や和集合を求めることができる
      ```Python
      d1 = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
      d2 = {"grape": "ぶどう", "orange": "蜜柑", "pear": "なし", "apple": "林檎"}
      print(d1.keys() & d2.keys())
      ```
  - **複数の辞書を結合する**
    - 辞書そのものに対して、「|」(論理和)の演算子を用いた場合は、複数の辞書を結合できる。
      ```Python
      d1 = {"apple": "りんご", "melon": "メロン"}
      d2 = {"grape": "ぶどう", "pear": "なし", "apple": "林檎"}
      print(d1 | d2)
      print(d2 | d1)
      ```
  - **規定値を持つ辞書を定義する ----defaultdict**
    - リストdataに含まれるそれぞれの名前の出現数をカウントするためのコード

      ```Python
      data = ["太郎", "花子", "次郎", "太郎", "太郎", "太郎", "花子"]
      result = {}

      for key in data:
          if key in result:
              result[key] += 1
          else:
              result[key] = 1

      print(result)
      ```

    - いちいち初期化の判定をするのが面倒に思える。collectionsモジュールのdefaultdict型を利用する

      ```Python
      from collections import defaultdict

      data = ["太郎", "花子", "次郎", "太郎", "太郎", "太郎", "花子"]
      result = defaultdict(int)

      for key in data:
          result[key] += 1

      print(result)

      ```

      ```Python
      defaultdictコンストラクター

      defaultdict(factory[,args])

      factory: 規定値を生成する関数
      args: dictコンストラクター相当の引数
      ```

#### 📒 6.3.5 辞書内包表記

- リスト内包表記／セット内包表記と同様、辞書でも内包表記を利用できる

  ```Python
  {キー： 値 for 仮変数 in イテラブル if 条件式}
  ```

  ```Python
  d = {"apple": "りんご", "orange": "みかん", "melon": "メロン"}
  result = {value: key for key, value in d.items()}
  print(result)
  ```

#### 📒 6.3.6 辞書型でのパターンマッチング

- パターンマッチングは辞書型に対しても用いることができる(**マッピングパターン**)

  ```Python
  # 書籍情報を表す辞書
  book = {
      "isbn": "978-4-7981-8055-7",
      "title": "独習 ASP.NET Core",
      "publisher": "翔泳社",
      "price": 4290,
      "page": 672,
  }

  # 記事情報を表す辞書
  article = {
      "url": "https://codezine.jp/article/corner/1009",
      "title": "「GitHub Copilot」 入門",
      "time": 8,
  }

  match book:
      case {"isbn": _, "title": title, "publisher": publisher}:
          print(f"{title} ({publisher}刊)")
      case {"url": url, "title": title}:
          print(f"{title} ({url})")
      case _:
          print("コンテンツの種類が不明です。")
  ```

- **複数のキーをまとめてキャプチャーする**
  - 「\*\*変数」で、指定されなかったキーをまとめてキャプチャすることもできる

    ```Python
    # 書籍情報を表す辞書
    book = {
        "isbn": "978-4-7981-8055-7",
        "title": "独習 ASP.NET Core",
        "publisher": "翔泳社",
        "price": 4290,
        "page": 672,
    }

    match book:
        case {"isbn": _, "title": title, **info}:
            print(f"{title} ({info})")
        case {"url": url, "title": title}:
            print(f"{title} ({url})")
    ```

## 📒 7. 標準ライブラリ

- 正規表現
- ファイルの操作
- HTTP通信
- 数学演算など

### 📒 7.1 正規表現

- **正規表現**とは「あいまいな文字列パターンを表現する記法」です。

#### 📒 7.1.1 正規表現の基本

- 正規表現によって表されたある文字列パターンのことを**正規表現パターン**という。ある文字列の中に含まれる場合、文字列が正規表現パターンに**マッチする**と言います。

#### 📒 7.1.2 文字列が正規表現パターンにマッチしたかを判定する

```Python
import re

msg = "電話番号は080-111-9999です。"
# 正規表現の準備
ptn = re.compile(r"(\d{2,4})-(\d{2,4})-(\d{4})")
# 文字列を検索&結果を表示
if result := ptn.search(msg):
    print(result.group(0))
    print(result.group(1))
    print(result.group(2))
    print(result.group(3))
else:
    print("見つかりませんでした。")
```

- 正規表現を利用するには、まず、reモジュールのcompile関数で正規表現を準備する。

  ```Python
  compile(pattern, flags=0)

  pattern: 正規表現パターン
  flags: 正規表現オプション
  ```

  ```Python
  ptn.search(string[, pos, [endpos]])

  ptn: Patternオブジェクト
  string: 検索対象の文字列
  pos: 検索開始位置
  endpos: 検索終了位置
  ```

  | メソッド／属性      | 概要                                                    |
  | :------------------ | :------------------------------------------------------ |
  | group([group, ...]) | group番目にマッチした部分文字を取得                     |
  | start([group])      | 開始位置を取得                                          |
  | end([group])        | 終了位置を取得                                          |
  | span([group])       | 「開始位置,終了位置」形式のタプルを取得                 |
  | expand(templ)       | マッチした結果をテンプレートtemplに埋め込んだ結果を取得 |
  | pos                 | 検索時に指定された開始位置                              |
  | endpos              | 検索時に指定された終了位置                              |
  | lastindex           | 最後にマッチしたインデックス                            |
  | lastgroup           | 最後にマッチしたグループの名前                          |

#### 📒 7.1.3 マッチしたすべての文字列を取得する

- search/matchメソッドで得られる結果は、いずれも最初にマッチした文字列1つだけ、もしもマッチした文字列をすべて取得したいなら、findall/finditerメソッドを利用する

```Python
ptn.findall(string[,pos[,endopos]])
ptn.finditer(string[,pos[,endopos]])

ptn: Patternオブジェクト
string: 文字列
pos: 検索開始位置
endpos: 検索終了位置
```

#### 📒 7.1.4 正規表現オプションでマッチング時の挙動を制御する

- Patternクラスをインスタンス化する際には、第2引数に検索オプション(マッチフラグ)を渡すこともできる。

  | 設定値        | 概要                                                       |
  | :------------ | :--------------------------------------------------------- |
  | IGNORECASE、I | 大文字小文字を区別しない                                   |
  | MULTILINE、M  | 複数行モードの有効化                                       |
  | DOTALL、S     | 「.」が行末記号を含む任意の文字にマッチ(単一行モード)      |
  | VERBOSE、X    | 空白とコメントを有効化                                     |
  | ASCII、A      | \w/\W、\b/\B、\d/\D、\s/\SでASCII文字に限定したマッチ【1】 |
  | LOCALE、L     | \w、\Wなどをロケールに従って処理                           |

- **大文字／小文字を区別しない**

  ```Python
  import re

  msg = "仕事はwings@example.comです。プライベート用はYAMA@example.comです。"
  ptn = re.compile(
      r"[a-z0-9.!#$%&\'*+/=?^_{|}~-]+@[a-z0-9-]+(\.[a-z0-9-]+)*", re.IGNORECASE
  )
  results = ptn.finditer(msg)
  for result in results:
      print(result.group())
  ```
